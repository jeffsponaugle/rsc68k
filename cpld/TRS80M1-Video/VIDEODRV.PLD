Name	 VGA4A;
PartNo   VGA4A;
Date     05/10/2022;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1504ispplcc44;

PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};

Pin[43] = CLK_25M;                  /* 25.175Mhz input clock  - Master Pixel Clock */
Pin[1]  = RESET_IN;                /* Active Low Reset */
Pin[5]  = SYNC_OUT;
Pin[4]  = PIXEL_OUT;

NODE [HSYNC_COUNTER0..9];
NODE [VSYNC_COUNTER0..9];
NODE VSYNC_CLOCK_A,VSYNC_CLOCK_B;
Pin =CLK_12M;
Pin =HSYNC_ZERO;
Pin =VSYNC_ZERO;

CLK_12M.d = !CLK_12M;
CLK_12M.ck = CLK_25M;
CLK_12M.ar = !RESET_IN;

/* Horizontal Sync 10 bit counter, 0-799.  HSYNC_ZERO is used to reset this counter so it loops from 799 back to 0 */

HSYNC_COUNTER0.d = !HSYNC_COUNTER0 & HSYNC_ZERO;
HSYNC_COUNTER0.ck = CLK_12M;
HSYNC_COUNTER0.ar = !RESET_IN;

HSYNC_COUNTER1.d = ((HSYNC_COUNTER0&!HSYNC_COUNTER1) # (!HSYNC_COUNTER0&HSYNC_COUNTER1)) & HSYNC_ZERO;
HSYNC_COUNTER1.ck = CLK_12M;
HSYNC_COUNTER1.ar = !RESET_IN;

HSYNC_COUNTER2T = HSYNC_COUNTER0&HSYNC_COUNTER1;
HSYNC_COUNTER2.d = ((HSYNC_COUNTER2T&!HSYNC_COUNTER2) # (!HSYNC_COUNTER2T&HSYNC_COUNTER2)) & HSYNC_ZERO;
HSYNC_COUNTER2.ck = CLK_12M;
HSYNC_COUNTER2.ar = !RESET_IN;

HSYNC_COUNTER3T = HSYNC_COUNTER2T&HSYNC_COUNTER2;
HSYNC_COUNTER3.d = ((HSYNC_COUNTER3T&!HSYNC_COUNTER3) # (!HSYNC_COUNTER3T&HSYNC_COUNTER3)) & HSYNC_ZERO;
HSYNC_COUNTER3.ck = CLK_12M;
HSYNC_COUNTER3.ar = !RESET_IN;

HSYNC_COUNTER4T = HSYNC_COUNTER3T&HSYNC_COUNTER3;
HSYNC_COUNTER4.d = ((HSYNC_COUNTER4T&!HSYNC_COUNTER4) # (!HSYNC_COUNTER4T&HSYNC_COUNTER4)) & HSYNC_ZERO;
HSYNC_COUNTER4.ck = CLK_12M;
HSYNC_COUNTER4.ar = !RESET_IN;

HSYNC_COUNTER5T = HSYNC_COUNTER4T&HSYNC_COUNTER4;
HSYNC_COUNTER5.d = ((HSYNC_COUNTER5T&!HSYNC_COUNTER5) # (!HSYNC_COUNTER5T&HSYNC_COUNTER5)) & HSYNC_ZERO;
HSYNC_COUNTER5.ck = CLK_12M;
HSYNC_COUNTER5.ar = !RESET_IN;

HSYNC_COUNTER6T = HSYNC_COUNTER5T&HSYNC_COUNTER5;
HSYNC_COUNTER6.d = ((HSYNC_COUNTER6T&!HSYNC_COUNTER6) # (!HSYNC_COUNTER6T&HSYNC_COUNTER6)) & HSYNC_ZERO;
HSYNC_COUNTER6.ck = CLK_12M;
HSYNC_COUNTER6.ar = !RESET_IN;

HSYNC_COUNTER7T = HSYNC_COUNTER6T&HSYNC_COUNTER6;
HSYNC_COUNTER7.d = ((HSYNC_COUNTER7T&!HSYNC_COUNTER7) # (!HSYNC_COUNTER7T&HSYNC_COUNTER7)) & HSYNC_ZERO;
HSYNC_COUNTER7.ck = CLK_12M;
HSYNC_COUNTER7.ar = !RESET_IN;

HSYNC_COUNTER8T = HSYNC_COUNTER7T&HSYNC_COUNTER7;
HSYNC_COUNTER8.d = ((HSYNC_COUNTER8T&!HSYNC_COUNTER8) # (!HSYNC_COUNTER8T&HSYNC_COUNTER8)) & HSYNC_ZERO;
HSYNC_COUNTER8.ck = CLK_12M;
HSYNC_COUNTER8.ar = !RESET_IN;

HSYNC_COUNTER9T = HSYNC_COUNTER8T&HSYNC_COUNTER8;
HSYNC_COUNTER9.d = ((HSYNC_COUNTER9T&!HSYNC_COUNTER9) # (!HSYNC_COUNTER9T&HSYNC_COUNTER9)) & HSYNC_ZERO;
HSYNC_COUNTER9.ck = CLK_12M;
HSYNC_COUNTER9.ar = !RESET_IN;

FIELD hsync_counter_field = [HSYNC_COUNTER9..0];
FIELD hsync_counter_3_field = [HSYNC_COUNTER2..0];
FIELD hsync_counter_4_field = [HSYNC_COUNTER3..0];

/* 
   HSYNC_ZERO is 0 when we need to loop the counter.  This is Logical AND'ed with the other inputs to each
   counters .d value, so when we are at the loop location, the next location loaded will be 0.
   HSYNC_ZERO us normally at 1, and goes to 0 for 1 clock cycle ( CLK25 low to CLK25 low ), and that
   edge is also used to increment the vertical counters via VSYNC_CLOCK.
*/

HSYNC_ZERO = !(hsync_counter_field:['d'799]);

/* 
   The VSYNC_CLOCK signal is used to increment the V_SYNC counter at the end of each horizontal sync row.   
   The reason for two FFs is to first capture the HSYNC value (on the clock edge opposite of the counter itself changing)
   followed by a second FF to sync the V_SYNC increment with the rising edge of CLK_25M.   This allows both the H_SYNC and V_SYNC 
   counters to be used in logical operations that are clocked on the same clock signal (falling CLK_25M)
*/


VSYNC_CLOCK_A.d = !HSYNC_ZERO;
VSYNC_CLOCK_A.ck = !CLK_12M;
VSYNC_CLOCK_A.ar = !RESET_IN;

VSYNC_CLOCK_B.d = VSYNC_CLOCK_A;
VSYNC_CLOCK_B.ck = CLK_12M;
VSYNC_CLOCK_B.ar = !RESET_IN;

/* Vertical Sync 9 bit counter, 0-498.  VSYNC_ZERO is used to reset this counter so it loops from 498 back to 0 */

VSYNC_COUNTER0.d = (!VSYNC_COUNTER0) & VSYNC_ZERO;
VSYNC_COUNTER0.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER0.ar = !RESET_IN;

VSYNC_COUNTER1.d = ((VSYNC_COUNTER0&!VSYNC_COUNTER1) # (!VSYNC_COUNTER0&VSYNC_COUNTER1)) & VSYNC_ZERO;
VSYNC_COUNTER1.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER1.ar = !RESET_IN;

VSYNC_COUNTER2T = VSYNC_COUNTER0&VSYNC_COUNTER1;
VSYNC_COUNTER2.d = ((VSYNC_COUNTER2T&!VSYNC_COUNTER2) # (!VSYNC_COUNTER2T&VSYNC_COUNTER2)) & VSYNC_ZERO;
VSYNC_COUNTER2.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER2.ar = !RESET_IN;

VSYNC_COUNTER3T = VSYNC_COUNTER2T&VSYNC_COUNTER2;
VSYNC_COUNTER3.d = ((VSYNC_COUNTER3T&!VSYNC_COUNTER3) # (!VSYNC_COUNTER3T&VSYNC_COUNTER3)) & VSYNC_ZERO;
VSYNC_COUNTER3.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER3.ar = !RESET_IN;

VSYNC_COUNTER4T = VSYNC_COUNTER3T&VSYNC_COUNTER3;
VSYNC_COUNTER4.d = ((VSYNC_COUNTER4T&!VSYNC_COUNTER4) # (!VSYNC_COUNTER4T&VSYNC_COUNTER4)) & VSYNC_ZERO;
VSYNC_COUNTER4.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER4.ar = !RESET_IN;

VSYNC_COUNTER5T = VSYNC_COUNTER4T&VSYNC_COUNTER4;
VSYNC_COUNTER5.d = ((VSYNC_COUNTER5T&!VSYNC_COUNTER5) # (!VSYNC_COUNTER5T&VSYNC_COUNTER5)) & VSYNC_ZERO;
VSYNC_COUNTER5.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER5.ar = !RESET_IN;

VSYNC_COUNTER6T = VSYNC_COUNTER5T&VSYNC_COUNTER5;
VSYNC_COUNTER6.d = ((VSYNC_COUNTER6T&!VSYNC_COUNTER6) # (!VSYNC_COUNTER6T&VSYNC_COUNTER6)) & VSYNC_ZERO;
VSYNC_COUNTER6.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER6.ar = !RESET_IN;

VSYNC_COUNTER7T = VSYNC_COUNTER6T&VSYNC_COUNTER6;
VSYNC_COUNTER7.d = ((VSYNC_COUNTER7T&!VSYNC_COUNTER7) # (!VSYNC_COUNTER7T&VSYNC_COUNTER7)) & VSYNC_ZERO;
VSYNC_COUNTER7.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER7.ar = !RESET_IN;

VSYNC_COUNTER8T = VSYNC_COUNTER7T&VSYNC_COUNTER7;
VSYNC_COUNTER8.d = ((VSYNC_COUNTER8T&!VSYNC_COUNTER8) # (!VSYNC_COUNTER8T&VSYNC_COUNTER8)) & VSYNC_ZERO;
VSYNC_COUNTER8.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER8.ar = !RESET_IN;

VSYNC_COUNTER9T = VSYNC_COUNTER8T&VSYNC_COUNTER8;
VSYNC_COUNTER9.d = ((VSYNC_COUNTER9T&!VSYNC_COUNTER9) # (!VSYNC_COUNTER9T&VSYNC_COUNTER9)) & VSYNC_ZERO;
VSYNC_COUNTER9.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER9.ar = !RESET_IN;

FIELD vsync_counter_field = [VSYNC_COUNTER9..0];
FIELD vsync_counter_4_field = [VSYNC_COUNTER3..0];

VSYNC_ZERO = !(vsync_counter_field:['d'263]);

/* VSYNC_DISPLAY_ACTIVE == 1 when on an active output row that we want to output pixel data.  Rows 32-223 (192 rows) */
VSYNC_DISPLAY_ACTIVE = (vsync_counter_field:['d'40..'d'231]);

/* VSYNC_OUTPUT_VSYNC == 1 when on a row that we want to output a vertical sync signal on. The last 3 rows */
VSYNC_OUTPUT_VSYNC = (vsync_counter_field:['d'262..'d'263]);

/* HSYNC_DISPLAY_ACTIVE == 1 when on the part of a line where we want output pixel data */
HSYNC_DISPLAY_ACTIVE = (hsync_counter_field:['d'196..'d'707]);

/* VSYNC_PATTERN describes what a SYNC output line looks like for the display to see a Vertical SYNC, but inverted.  
   This value is ==1 at the locations that we want the SYNC signal to be 0. */
VSYNC_PATTERN = (hsync_counter_field:['d'0..'d'639]);

/* HSYNC_PATTERN describes what a SYNC output line looks like for the display to see a Horizontal SYNC, but inverted.  
   This value is ==1 at the locations that we want the SYNC signal to be 0. */
HSYNC_PATTERN = (hsync_counter_field:['d'0..'d'63]);


/* The actual SYNC output pin is either doing a line with the HSYNC pattern, or the VSYNC pattern */

SYNC_OUT.d = !( 
                 (VSYNC_OUTPUT_VSYNC & VSYNC_PATTERN)
               # (!VSYNC_OUTPUT_VSYNC & HSYNC_PATTERN)
              );
SYNC_OUT.ck = !CLK_12M;
SYNC_OUT.ap = !RESET_IN;

PIXEL_OUT.d = (HSYNC_DISPLAY_ACTIVE & VSYNC_DISPLAY_ACTIVE & HSYNC_COUNTER0 & VSYNC_COUNTER0);
PIXEL_OUT.ck = !CLK_12M;
PIXEL_OUT.ar = !RESET_IN;

/*
Total dedicated input used:	2/4 	(50%)
Total I/O pins used		6/32 	(18%)
Total Logic cells used 		44/64 	(68%)
Total Flip-Flop used 		25/64 	(39%)
Total Foldback logic used 	0/64 	(0%)
Total Nodes+FB/MCells 		25/64 	(39%)
Total cascade used 		19
Total input pins 		6
Total output pins 		2
Total Pts 			156
*/