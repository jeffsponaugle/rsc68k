Name	 VGA;
PartNo   VGA;
Date     05/10/2022;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1508ispplcc84;


/* 
   Version 1.0
    First Pass
   
*/

/*
    

    Pins                Text Mode                                       Graphics Mode          
    VDB_A0-A6           HC3-9                                           HC4-9, VC0
    VDB_A7-A15          VC4-9,0,0,                                      VC1-9
    FRAM_A0-A3          VC0-3                                           0 or VC0-3
    VRAM_LOW_CE         RAM_OE                                          RAM_OE # HC3
    VRAM_HIGH_CE        RAM_OE                                          RAM_OE # !HC3
    VRAM_OE             RAM_OE                                          RAM_OE
    VRAM_WE             'b'1 (disabled)                                 'b'1
    VDB_HTOL            'b'1 (disabled)                                 !HC3
    FRAM_OE             RAM_OE                                          RAM_OE
    SR_LOAD             SR_LOAD                                         SR_LOAD
    SR_CE               SR_CE                                           SR_CE
    HSYNC               !(hsync_counter_field:['d'664..'d'759]);        same
    VSYNC               !(vsync_counter_field:['d'490..'d'491]);        same
    GRAPH_MODE          'b'0                                            'b'1

    If extra pin/io, add two output bits for the A13/A14 in text mode, as that will allow selection of text
    pages to display.

    FROM CPU
    --------
    CPU_R-/W
    CPU_/UDS
    CPU_/LDS
    EXP_CS_C  Chip select for video memory (AS Gated)
    EXP_CS_B  Chip select for VGA configuration (AS Gated)
    VGA_BUSY  Output back to CPU to indicate pause in transaction ( DTACK )  == 0 when access paused.

    VRAM_AD_OE  Enable Address and Dataline buffers from CPU to video memory.

    VGA_CPU_ACCESS_ALLOWED - (hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
    VGA_BUSY - FF clocked to RAM_OE by EXP_CS_C, Cleared to 1 by VGA_BUSY==1.

    
    
*/

/*  
               MHz	   Horizontal (in Pixels)	                           Vertical (in Lines)
Format	Pixel Clock    Active Video   Front_Porch Sync_Pulse  Back_Porch	Active_Video	Front_Porch	Sync_Pulse Back_Porch
640x480, 60Hz	25.175	640	         16	         -96	      48	         480	         11	        -2	         31
640x480, 72Hz	31.500	640	         24	         -40	      128	      480	         9	        -3	         2

*/


PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};

/** Inputs **/

Pin[83] = CLK_25M;
Pin[1]  = VGA_RESET;               /* Active Low Reset */
Pin[2]  = CPU_VGA_VRAM_CS;
Pin[74] = CPU_VGA_CFG_CS;
Pin[76] = CPU_UDS;
Pin[44] = CPU_LDS;
Pin[73] = CPU_RW;

/** Outputs **/
Pin[9]  = SR_CE;
Pin[49] = SR_LOAD;
Pin[24] = VGA_HSYNC;
Pin[10] = VGA_VSYNC;
Pin[30] = VRAM_LOW_CE;
Pin[29] = VRAM_HIGH_CE;
Pin[34] = VRAM_OE;          /* Could also be used for FRAM_OE - Consider CPU Access? */
Pin[52] = VRAM_WE;
Pin[31] = VDP_HTOL;
Pin[35] = GRAPH_MODE;
Pin[11,12]  = FONTSEL0, FONTSEL1;
Pin[18,20,21,22,25,27,28,8,6,5,4,15,16,40,41,51] = [VDB_A0..15];
          /* Address lines to video memory */
Pin[33,36,37,39] = [FRAM_A0..3];          /* Address lines to lower 4 bits of Char ROM, for font row */
Pin[45,46,48,54,55,56,57,75] = [CPU_D0..7];
Pin[17] = CPU_VRAM_DTACK;
Pin[50] = SBUS_TO_VRAM_AD_OE;
Pin[61] = VERT_SYNC_INTERRUPT;

NODE [HSYNC_COUNTER0..9];
NODE [VSYNC_COUNTER0..9];
NODE VSYNC_CLOCK_A,VSYNC_CLOCK_B;
NODE SR_LOAD_PRE;
NODE VGA_BUSY,VGA_BUSY_CSLOCKED, CPU_VRAM_CS_CLOCKED , CPU_VRAM_ACCESS_ENABLED;
NODE TXTOFFSET0,TXTOFFSET1,TXTOFFSET2,TXTOFFSET3,TXTOFFSET4;
NODE RAM_OE;


/*
   VGA Config registers.  WRITE ONLY, BYTE WRITE ONLY.
      bit 0 = MODE, 0 for TXT, 1 for Graphics; 0 on RESET
      bit 1 = FONTSEL0   FONTSEL selects from 4 font libraries stored in the FONT ROM
      bit 2 = FONTSEL1

      This register to clocked at the end of the write cycle with the deassertion of CS and R/W

*/

/*
   Access to VGA Config registers from CPU 
   CPU will assert /CPU_VGA_CFG_CS and /CPU_RW to indicate a write to the CGA config register.
   VGA_CONFIG_WRITE==1 when both CPU_CGA_CFG_CS and CPU_RW are asserted (==0). 
*/

VGA_CONFIG_WRITE = !(CPU_VGA_CFG_CS # CPU_RW);

GRAPH_MODE.d = CPU_D0.io;
GRAPH_MODE.ar = !VGA_RESET;
GRAPH_MODE.ck = !VGA_CONFIG_WRITE;

FONTSEL0.d = CPU_D1.io;
FONTSEL0.ar = !VGA_RESET;
FONTSEL0.ck = !VGA_CONFIG_WRITE;

FONTSEL1.d = CPU_D2.io;
FONTSEL1.ar = !VGA_RESET;
FONTSEL1.ck = !VGA_CONFIG_WRITE;

TXTOFFSET0.d = CPU_D3.io;
TXTOFFSET0.ar = !VGA_RESET;
TXTOFFSET0.ck = !VGA_CONFIG_WRITE;

TXTOFFSET1.d = CPU_D4.io;
TXTOFFSET1.ar = !VGA_RESET;
TXTOFFSET1.ck = !VGA_CONFIG_WRITE;

TXTOFFSET2.d = CPU_D5.io;
TXTOFFSET2.ar = !VGA_RESET;
TXTOFFSET2.ck = !VGA_CONFIG_WRITE;

TXTOFFSET3.d = CPU_D6.io;
TXTOFFSET3.ar = !VGA_RESET;
TXTOFFSET3.ck = !VGA_CONFIG_WRITE;

TXTOFFSET4.d = CPU_D7.io;
TXTOFFSET4.ar = !VGA_RESET;
TXTOFFSET4.ck = !VGA_CONFIG_WRITE;

/* VGA_BUSY is 1 when the VGA memory is bring used by the VGA interface *

/*  
   VRAM Address is based on the HSYNC counter bit 3-9 plus the VSYNC counter bits 0-8.
   A0-A6 = HSYNC_COUNTER3-9
   A7-A15 = VSYNC_COUNTER0-8

   This results in each 640 pixel line being 80 bytes of data, but 128 bytes apart.  Each Row takes 128 bytes 
   of memory with the first 80 bytes being display data and the remaining 48 bytes unused. 
   There are 480 rows, so a total of 480*128 = 61440 bytes of memory, thus 16 address lines.

   This is a slightly inefficient memory layout due to the horiontal counter not being a precise power of two.  This could be
   solved with a second 16 bit counter that is incremented during the correct parts of the horizontal cycle, however that would 
   require quite a bit of CPLD resources. (A 16 bit counter uses 16 FF and 37 logic cells if implemented as a single counter, 
   and 16FF and 23 logic cells if implemented as 2 8 bit counters with ripple)
*/

VDB_A0 = (!GRAPH_MODE & HSYNC_COUNTER3)
         # ((GRAPH_MODE & HSYNC_COUNTER4));
VDB_A1 = (!GRAPH_MODE & HSYNC_COUNTER4)
         # ((GRAPH_MODE & HSYNC_COUNTER5));
VDB_A2 = (!GRAPH_MODE & HSYNC_COUNTER5)
         # ((GRAPH_MODE & HSYNC_COUNTER6));
VDB_A3 = (!GRAPH_MODE & HSYNC_COUNTER6)
         # ((GRAPH_MODE & HSYNC_COUNTER7));
VDB_A4 = (!GRAPH_MODE & HSYNC_COUNTER7)
         # ((GRAPH_MODE & HSYNC_COUNTER8));
VDB_A5 = (!GRAPH_MODE & HSYNC_COUNTER8)
         # ((GRAPH_MODE & HSYNC_COUNTER9));
VDB_A6 = (!GRAPH_MODE & HSYNC_COUNTER9)
         # ((GRAPH_MODE & VSYNC_COUNTER0));

/* These 6 VDB address lines have adder results for text mode */

/* 6 bits of addition - VSYNC_COUNTER4-9 + TXTOFFSET0-4 */

P_TXTA7 = (VSYNC_COUNTER4 $ TXTOFFSET0);
G_TXTA7 = (VSYNC_COUNTER4 & TXTOFFSET0);
S_TXTA7 = P_TXTA7;
CO_TXTA7 = G_TXTA7;

P_TXTA8 = (VSYNC_COUNTER5 $ TXTOFFSET1);
G_TXTA8 = (VSYNC_COUNTER5 & TXTOFFSET1);
S_TXTA8 = P_TXTA8 $ CO_TXTA7;
CO_TXTA8 = G_TXTA8 # (P_TXTA8 & CO_TXTA7);

P_TXTA9 = (VSYNC_COUNTER6 $ TXTOFFSET2);
G_TXTA9 = (VSYNC_COUNTER6 & TXTOFFSET2);
S_TXTA9 = P_TXTA9 $ CO_TXTA8;
CO_TXTA9 = G_TXTA9 # (P_TXTA9 & CO_TXTA8);

P_TXTA10 = (VSYNC_COUNTER7 $ TXTOFFSET3);
G_TXTA10 = (VSYNC_COUNTER7 & TXTOFFSET3);
S_TXTA10 = P_TXTA10 $ CO_TXTA9;
CO_TXTA10 = G_TXTA10 # (P_TXTA10 & CO_TXTA9);

P_TXTA11 = (VSYNC_COUNTER8 $ TXTOFFSET4);
G_TXTA11 = (VSYNC_COUNTER8 & TXTOFFSET4);
S_TXTA11 = P_TXTA11 $ CO_TXTA10;
CO_TXTA11 = G_TXTA11 # (P_TXTA11 & CO_TXTA10);

P_TXTA12 = (VSYNC_COUNTER9);
S_TXTA12 = P_TXTA11 $ CO_TXTA11;
CO_TXTA12 = (P_TXTA11 & CO_TXTA11);


VDB_A7  = (!GRAPH_MODE & S_TXTA7)
         # ((GRAPH_MODE & VSYNC_COUNTER1));
VDB_A8  = (!GRAPH_MODE & S_TXTA8)
         # ((GRAPH_MODE & VSYNC_COUNTER2));
VDB_A9  = (!GRAPH_MODE & S_TXTA9)
         # ((GRAPH_MODE & VSYNC_COUNTER3));
VDB_A10 = (!GRAPH_MODE & S_TXTA10)
         # ((GRAPH_MODE & VSYNC_COUNTER4));
VDB_A11 = (!GRAPH_MODE & S_TXTA11)
         # ((GRAPH_MODE & VSYNC_COUNTER5));
VDB_A12 = (!GRAPH_MODE & S_TXTA12)
         # ((GRAPH_MODE & VSYNC_COUNTER6));



VDB_A13 = (!GRAPH_MODE & 'd'0)
         # ((GRAPH_MODE & VSYNC_COUNTER7));
VDB_A14 = (!GRAPH_MODE & 'd'0)
         # ((GRAPH_MODE & VSYNC_COUNTER8));
VDB_A15 = (!GRAPH_MODE & 'd'0)
         # ((GRAPH_MODE & VSYNC_COUNTER9));


[VDB_A0..15].oe = !RAM_OE;

FRAM_A0 = (!GRAPH_MODE & VSYNC_COUNTER0)
         # ((GRAPH_MODE & 'd'0));
FRAM_A1 = (!GRAPH_MODE & VSYNC_COUNTER1)
         # ((GRAPH_MODE & 'd'0));
FRAM_A2 = (!GRAPH_MODE & VSYNC_COUNTER2)
         # ((GRAPH_MODE & 'd'0));
FRAM_A3 = (!GRAPH_MODE & VSYNC_COUNTER3)
         # ((GRAPH_MODE & 'd'0));


/* Horizontal Sync 10 bit counter, 0-799.  HSYNC_ZERO is used to reset this counter so it loops from 799 back to 0 */

HSYNC_COUNTER0.d = !HSYNC_COUNTER0 & HSYNC_ZERO;
HSYNC_COUNTER0.ck = CLK_25M;
HSYNC_COUNTER0.ar = !VGA_RESET;

HSYNC_COUNTER1.d = ((HSYNC_COUNTER0&!HSYNC_COUNTER1) # (!HSYNC_COUNTER0&HSYNC_COUNTER1)) & HSYNC_ZERO;
HSYNC_COUNTER1.ck = CLK_25M;
HSYNC_COUNTER1.ar = !VGA_RESET;

HSYNC_COUNTER2T = HSYNC_COUNTER0&HSYNC_COUNTER1;
HSYNC_COUNTER2.d = ((HSYNC_COUNTER2T&!HSYNC_COUNTER2) # (!HSYNC_COUNTER2T&HSYNC_COUNTER2)) & HSYNC_ZERO;
HSYNC_COUNTER2.ck = CLK_25M;
HSYNC_COUNTER2.ar = !VGA_RESET;

HSYNC_COUNTER3T = HSYNC_COUNTER2T&HSYNC_COUNTER2;
HSYNC_COUNTER3.d = ((HSYNC_COUNTER3T&!HSYNC_COUNTER3) # (!HSYNC_COUNTER3T&HSYNC_COUNTER3)) & HSYNC_ZERO;
HSYNC_COUNTER3.ck = CLK_25M;
HSYNC_COUNTER3.ar = !VGA_RESET;

HSYNC_COUNTER4T = HSYNC_COUNTER3T&HSYNC_COUNTER3;
HSYNC_COUNTER4.d = ((HSYNC_COUNTER4T&!HSYNC_COUNTER4) # (!HSYNC_COUNTER4T&HSYNC_COUNTER4)) & HSYNC_ZERO;
HSYNC_COUNTER4.ck = CLK_25M;
HSYNC_COUNTER4.ar = !VGA_RESET;

HSYNC_COUNTER5T = HSYNC_COUNTER4T&HSYNC_COUNTER4;
HSYNC_COUNTER5.d = ((HSYNC_COUNTER5T&!HSYNC_COUNTER5) # (!HSYNC_COUNTER5T&HSYNC_COUNTER5)) & HSYNC_ZERO;
HSYNC_COUNTER5.ck = CLK_25M;
HSYNC_COUNTER5.ar = !VGA_RESET;

HSYNC_COUNTER6T = HSYNC_COUNTER5T&HSYNC_COUNTER5;
HSYNC_COUNTER6.d = ((HSYNC_COUNTER6T&!HSYNC_COUNTER6) # (!HSYNC_COUNTER6T&HSYNC_COUNTER6)) & HSYNC_ZERO;
HSYNC_COUNTER6.ck = CLK_25M;
HSYNC_COUNTER6.ar = !VGA_RESET;

HSYNC_COUNTER7T = HSYNC_COUNTER6T&HSYNC_COUNTER6;
HSYNC_COUNTER7.d = ((HSYNC_COUNTER7T&!HSYNC_COUNTER7) # (!HSYNC_COUNTER7T&HSYNC_COUNTER7)) & HSYNC_ZERO;
HSYNC_COUNTER7.ck = CLK_25M;
HSYNC_COUNTER7.ar = !VGA_RESET;

HSYNC_COUNTER8T = HSYNC_COUNTER7T&HSYNC_COUNTER7;
HSYNC_COUNTER8.d = ((HSYNC_COUNTER8T&!HSYNC_COUNTER8) # (!HSYNC_COUNTER8T&HSYNC_COUNTER8)) & HSYNC_ZERO;
HSYNC_COUNTER8.ck = CLK_25M;
HSYNC_COUNTER8.ar = !VGA_RESET;

HSYNC_COUNTER9T = HSYNC_COUNTER8T&HSYNC_COUNTER8;
HSYNC_COUNTER9.d = ((HSYNC_COUNTER9T&!HSYNC_COUNTER9) # (!HSYNC_COUNTER9T&HSYNC_COUNTER9)) & HSYNC_ZERO;
HSYNC_COUNTER9.ck = CLK_25M;
HSYNC_COUNTER9.ar = !VGA_RESET;

FIELD hsync_counter_field = [HSYNC_COUNTER9..0];
FIELD hsync_counter_3_field = [HSYNC_COUNTER2..0];

/* 
   HSYNC_ZERO is 0 when we need to loop the counter.  This is Logical AND'ed with the other inputs to each
   counters .d value, so when we are at the loop location, the next location loaded will be 0.
   HSYNC_ZERO us normally at 1, and goes to 0 for 1 clock cycle ( CLK25 low to CLK25 low ), and that
   edge is also used to increment the vertical counters via VSYNC_CLOCK.
*/

HSYNC_ZERO = !(hsync_counter_field:['d'799]);

/* 
   The VSYNC_CLOCK signal is used to increment the V_SYNC counter at the end of each horizontal sync row.   
   The reason for two FFs is to first capture the HSYNC value (on the clock edge opposite of the counter itself changing)
   followed by a second FF to sync the V_SYNC increment with the rising edge of CLK_25M.   This allows both the H_SYNC and V_SYNC 
   counters to be used in logical operations that are clocked on the same clock signal (falling CLK_25M)
*/


VSYNC_CLOCK_A.d = !HSYNC_ZERO;
VSYNC_CLOCK_A.ck = !CLK_25M;
VSYNC_CLOCK_A.ar = !VGA_RESET;

VSYNC_CLOCK_B.d = VSYNC_CLOCK_A;
VSYNC_CLOCK_B.ck = CLK_25M;
VSYNC_CLOCK_B.ar = !VGA_RESET;

/* Vertical Sync 9 bit counter, 0-498.  VSYNC_ZERO is used to reset this counter so it loops from 498 back to 0 */

VSYNC_COUNTER0.d = (!VSYNC_COUNTER0) & VSYNC_ZERO;
VSYNC_COUNTER0.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER0.ar = !VGA_RESET;

VSYNC_COUNTER1.d = ((VSYNC_COUNTER0&!VSYNC_COUNTER1) # (!VSYNC_COUNTER0&VSYNC_COUNTER1)) & VSYNC_ZERO;
VSYNC_COUNTER1.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER1.ar = !VGA_RESET;

VSYNC_COUNTER2T = VSYNC_COUNTER0&VSYNC_COUNTER1;
VSYNC_COUNTER2.d = ((VSYNC_COUNTER2T&!VSYNC_COUNTER2) # (!VSYNC_COUNTER2T&VSYNC_COUNTER2)) & VSYNC_ZERO;
VSYNC_COUNTER2.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER2.ar = !VGA_RESET;

VSYNC_COUNTER3T = VSYNC_COUNTER2T&VSYNC_COUNTER2;
VSYNC_COUNTER3.d = ((VSYNC_COUNTER3T&!VSYNC_COUNTER3) # (!VSYNC_COUNTER3T&VSYNC_COUNTER3)) & VSYNC_ZERO;
VSYNC_COUNTER3.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER3.ar = !VGA_RESET;

VSYNC_COUNTER4T = VSYNC_COUNTER3T&VSYNC_COUNTER3;
VSYNC_COUNTER4.d = ((VSYNC_COUNTER4T&!VSYNC_COUNTER4) # (!VSYNC_COUNTER4T&VSYNC_COUNTER4)) & VSYNC_ZERO;
VSYNC_COUNTER4.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER4.ar = !VGA_RESET;

VSYNC_COUNTER5T = VSYNC_COUNTER4T&VSYNC_COUNTER4;
VSYNC_COUNTER5.d = ((VSYNC_COUNTER5T&!VSYNC_COUNTER5) # (!VSYNC_COUNTER5T&VSYNC_COUNTER5)) & VSYNC_ZERO;
VSYNC_COUNTER5.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER5.ar = !VGA_RESET;

VSYNC_COUNTER6T = VSYNC_COUNTER5T&VSYNC_COUNTER5;
VSYNC_COUNTER6.d = ((VSYNC_COUNTER6T&!VSYNC_COUNTER6) # (!VSYNC_COUNTER6T&VSYNC_COUNTER6)) & VSYNC_ZERO;
VSYNC_COUNTER6.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER6.ar = !VGA_RESET;

VSYNC_COUNTER7T = VSYNC_COUNTER6T&VSYNC_COUNTER6;
VSYNC_COUNTER7.d = ((VSYNC_COUNTER7T&!VSYNC_COUNTER7) # (!VSYNC_COUNTER7T&VSYNC_COUNTER7)) & VSYNC_ZERO;
VSYNC_COUNTER7.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER7.ar = !VGA_RESET;

VSYNC_COUNTER8T = VSYNC_COUNTER7T&VSYNC_COUNTER7;
VSYNC_COUNTER8.d = ((VSYNC_COUNTER8T&!VSYNC_COUNTER8) # (!VSYNC_COUNTER8T&VSYNC_COUNTER8)) & VSYNC_ZERO;
VSYNC_COUNTER8.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER8.ar = !VGA_RESET;

VSYNC_COUNTER9T = VSYNC_COUNTER8T&VSYNC_COUNTER8;
VSYNC_COUNTER9.d = ((VSYNC_COUNTER9T&!VSYNC_COUNTER9) # (!VSYNC_COUNTER9T&VSYNC_COUNTER9)) & VSYNC_ZERO;
VSYNC_COUNTER9.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER9.ar = !VGA_RESET;

FIELD vsync_counter_field = [VSYNC_COUNTER9..0];
VSYNC_ZERO = !(vsync_counter_field:['d'524]);



/* VSYNC_DISPLAY_ACTIVE == 1 when on an active output row */
VSYNC_DISPLAY_ACTIVE = (vsync_counter_field:[0..'d'479]);

/* 
   VERT_SYNC_INTERRUPT is used to tell the CPU that we are entering the vertical refresh interval.
   VERY_SYNC_INTERRUPT goes to 1 during the active part of the display, and the falling edge indicates 
   entering the refresh interval
 */
VERT_SYNC_INTERRUPT = VSYNC_DISPLAY_ACTIVE;

/*  NOT USING
VGA_DISPLAY_ACTIVE.d = (hsync_counter_field:['d'8..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
VGA_DISPLAY_ACTIVE.ck = !CLK_25M;
VGA_DISPLAY_ACTIVE.ar = !VGA_RESET;
*/

/* 
   RAM_OE is used by the VRAM CE ,OE, and WE lines to select when the video adapter is using VRAM.  
   It is active low, so ==0 indicates VRAM is being used by the video adapter 
*/

RAM_OE.d = !((hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE));
RAM_OE.ck = !CLK_25M;
RAM_OE.ap = !VGA_RESET;

VGA_BUSY.d =  ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
VGA_BUSY.ck = !CLK_25M;
VGA_BUSY.ar = !VGA_RESET;


/* Control of VRAM */
/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle(including chip select), and ==1 when the VGA is in control */

VDP_HTOL =  (GRAPH_MODE & HSYNC_COUNTER3 & !RAM_OE);

VRAM_LOW_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_LDS );
VRAM_HIGH_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_UDS );
VRAM_OE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & !CPU_RW );
VRAM_WE = (CPU_VRAM_ACCESS_ENABLED # CPU_RW );

SR_LOAD_PRE.d =  (!(hsync_counter_3_field:[6]));
SR_LOAD_PRE.ck = !CLK_25M;

SR_LOAD.d = SR_LOAD_PRE;
SR_LOAD.ck = CLK_25M;
SR_LOAD.ar = !VGA_RESET;

/* SR_CE.d = !((hsync_counter_field:['d'7..'d'647]) & VSYNC_DISPLAY_ACTIVE); */

SR_CE.d = !((hsync_counter_field:['d'7..'d'647]) & (VSYNC_DISPLAY_ACTIVE) );
SR_CE.ck = !CLK_25M;
SR_CE.ar = !VGA_RESET;

VGA_HSYNC.d = !(hsync_counter_field:['d'664..'d'759]);
VGA_HSYNC.ck = !CLK_25M;
VGA_HSYNC.ap = !VGA_RESET;

VGA_VSYNC.d = !(vsync_counter_field:['d'490..'d'491]);
VGA_VSYNC.ck = !CLK_25M;
VGA_VSYNC.ar = !VGA_RESET;

/*
      VGA_BUSY is a flag that indicates if the Video memory can be accessed by the CPU.  
         == 1 indicates the video controller is usig the memory
         == 0 indicates the memory is available for CPU access.
         This needs to be active outside of the video access hcount, and during the vertical
         refresh period. It needs a guard band around the start time to guarentee a CPU cycle can
         complete before the video side needs access.  

         ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);


      VGA_BUSY_CSLOCKED is a version of VGA_BUSY that is clocked at the start of a CPU
         access cycle.  It is used to guarentee that the video memory cannot become busy during
         the middle of a CPU access cycle.  As such you have to guarentee there is enough guard 
         time around VGA_BUSY to account for a full cpu cycle (250ns, or 7 pixle clocks)
         This signal is also used to trigger the SBUS_TO_VRAM_AD_OE output, which turns on the
         buffers that connect the CPU bus to the Video memory bus. SBUS_TO_VRAM_AD_OE in enabled
         when this value is 0 AND CPU_VGA_VRAM_CS is asserted (==0).   

      CPU_VRAM_DTACK is the DTACK signal back to the CPU.  When it is 1, the CPU will add waitstates
         during an access until it goes to 0.  Once DTACK goes to 0, the CPU will complete the access cycle.
         This gate is clocked on CLK_25M, which guarentees a 19ns delay from when VGA_BUSY falls to 0.  Since the VRAM_AD_OE 
         is enabled as soon as VGA_BUSY falls, the address and data signals will have additional time to get to the VRAM.
         The VRAM OE/WE/CE signals should also be asserted using this same combinatorial. 
*/



VGA_BUSY_CSLOCKED.d = VGA_BUSY;
VGA_BUSY_CSLOCKED.ck = !CPU_VGA_VRAM_CS;
VGA_BUSY_CSLOCKED.ar = !VGA_BUSY # !VGA_RESET;

CPU_VRAM_CS_CLOCKED.d = CPU_VGA_VRAM_CS;
CPU_VRAM_CS_CLOCKED.ck = !CLK_25M;
CPU_VRAM_CS_CLOCKED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

CPU_VRAM_ACCESS_ENABLED.d = VGA_BUSY_CSLOCKED # CPU_VRAM_CS_CLOCKED;
CPU_VRAM_ACCESS_ENABLED.ck = CLK_25M;
CPU_VRAM_ACCESS_ENABLED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

CPU_VRAM_DTACK.d = CPU_VRAM_ACCESS_ENABLED;
CPU_VRAM_DTACK.ck = !CLK_25M;
CPU_VRAM_DTACK.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle, and ==1 when the VGA is in control */

SBUS_TO_VRAM_AD_OE = CPU_VRAM_ACCESS_ENABLED;

/*

Total dedicated input used:	3/4 	(75%)
Total I/O pins used		50/64 	(78%)
Total Logic cells used 		127/128 	(99%)
Total Flip-Flop used 		41/128 	(32%)
Total Foldback logic used 	6/128 	(4%)
Total Nodes+FB/MCells 		131/128 	(102%)
Total cascade used 		2
Total input pins 		19
Total output pins 		34
Total Pts 			482

Pin 1  = VGA_RESET;


Pin 37 = FRAM_A0; 
Pin 11 = FRAM_A1; 
Pin 12 = FRAM_A2;
Pin 39 = FRAM_A3;  

Pin 18 = VDB_A0;
Pin 20 = VDB_A1; 
Pin 21 = VDB_A2; 
Pin 25 = VDB_A3; 
Pin 22 = VDB_A4; 
Pin 27 = VDB_A5; 
Pin 28 = VDB_A6;
Pin 8  = VDB_A7;
Pin 6  = VDB_A8; 
Pin 4  = VDB_A9; 
Pin 5  = VDB_A10; 
Pin 15 = VDB_A11; 
Pin 16 = VDB_A12; 
Pin 40 = VDB_A13; 
Pin 41 = VDB_A14; 
Pin 51 = VDB_A15;

Pin 10 = VGA_VSYNC;  
Pin 24 = VGA_HSYNC; 
Pin 9  = SR_CE; 
Pin 49 = SR_LOAD; 

Pin 33 = FONTSEL0; 
Pin 36 = FONTSEL1; 
Pin 34 = VRAM_OE;  
Pin 35 = GRAPH_MODE; 

Pin 50 = SBUS_TO_VRAM_AD_OE; 

Pin 52 = VRAM_WE;  
Pin 29 = VRAM_HIGH_CE; 
Pin 30 = VRAM_LOW_CE; 
Pin 31 = VDP_HTOL; 

Pin 73 = CPU_RW; 
Pin 74 = CPU_VGA_CFG_CS;  
Pin 17 = CPU_VRAM_DTACK;
Pin 2  = CPU_VGA_VRAM_CS;

Pin 76 = CPU_UDS; 
Pin 83 = CLK_25M;
Pin 44 = CPU_LDS;  
 
Pin 56 = CPU_D0; 
Pin 55 = CPU_D1; 
Pin 57 = CPU_D2; 
Pin 75 = CPU_D3;  
Pin 46 = CPU_D4; 
Pin 45 = CPU_D5;
Pin 54 = CPU_D6; 
Pin 48 = CPU_D7; 
 

*/



