LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

  1:Name     VGA4A;
  2:PartNo   VGA4A;
  3:Date     05/10/2022;
  4:Revision 01;
  5:Designer Sponaugle;
  6:Company  Ratiometric;
  7:Assembly None;
  8:Location None;
  9:Device   f1508ispplcc84;
 10:
 11:
 12:/* 
 13:   Version 1.0
 14:    First Pass
 15:   
 16:*/
 17:
 18:/*
 19:    Text mode uses 1 address location per char, lower byte goes to FONT ROM then to SREG_IN, high byte comes in as attribute bits.
 20:    Graphics mode user 1 address location for 2 pixels,  pixel data cycles into the attribute bits.  
 21:
 22:    Pins                Text Mode (80x30 text, 640x480pix               Graphics Mode (640x480 8bpp)
 23:
 24:    VADDR_INCREMENT     ==1 every 8 HC Cycles (0-799)                   ==1 every 2 HC Cycles (0-799)
 25:    VADDR_RESET         ==1 at end of active cycle                      ==1 at end of active cycle
 26:    
 27:    FRAM_A0-A3          VC0-3                                           0 or VC0-3
 28:    VRAM_LOW_CE         RAM_OE                                          RAM_OE # HC3
 29:    VRAM_HIGH_CE        RAM_OE                                          RAM_OE # !HC3
 30:    VRAM_OE             RAM_OE                                          RAM_OE
 31:    VRAM_WE             'b'1 (disabled)                                 'b'1
 32:    VDB_HTOL            'b'1 (disabled)                                 !HC3
 33:    FRAM_OE             RAM_OE                                          RAM_OE
 34:    SR_LOAD             SR_LOAD                                         SR_LOAD
 35:    SR_CE               SR_CE                                           SR_CE
 36:    HSYNC               !(hsync_counter_field:['d'664..'d'759]);        same
 37:    VSYNC               !(vsync_counter_field:['d'490..'d'491]);        same
 38:    GRAPH_MODE0          'b'0                                            'b'1
 39:
 40:    If extra pin/io, add two output bits for the A13/A14 in text mode, as that will allow selection of text
 41:    pages to display.
 42:
 43:    FROM CPU
 44:    --------
 45:    CPU_R-/W
 46:    CPU_/UDS
 47:    CPU_/LDS
 48:    EXP_CS_C  Chip select for video memory (AS Gated)
 49:    EXP_CS_B  Chip select for VGA configuration (AS Gated)
 50:    VGA_BUSY  Output back to CPU to indicate pause in transaction ( DTACK )  == 0 when access paused.
 51:
 52:    VRAM_AD_OE  Enable Address and Dataline buffers from CPU to video memory.
 53:

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

 54:    VGA_CPU_ACCESS_ALLOWED - (hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
 55:    VGA_BUSY - FF clocked to RAM_OE by EXP_CS_C, Cleared to 1 by VGA_BUSY==1.
 56:
 57:    
 58:    
 59:*/
 60:
 61:/*  
 62:               MHz         Horizontal (in Pixels)                                  Vertical (in Lines)
 63:Format  Pixel Clock    Active Video   Front_Porch Sync_Pulse  Back_Porch        Active_Video    Front_Porch     Sync_Pulse Back_Porch
 64:640x480, 60Hz   25.175  640              16              -96          48                 480             11             -2               31
 65:640x480, 72Hz   31.500  640              24              -40          128             480                9              -3               2
 66:
 67:*/
 68:
 69:
 70:PROPERTY ATMEL {TDI_PULLUP = ON};
 71:PROPERTY ATMEL {TMS_PULLUP = ON};
 72:
 73:/** Inputs **/
 74:
 75:Pin[83] = CLK_25M;
 76:Pin[1]  = VGA_RESET;               /* Active Low Reset */
 77:Pin[8]  = CPU_VGA_VRAM_CS;
 78:Pin[9] = CPU_VGA_CFG_CS;
 79:Pin[10] = CPU_UDS;
 80:Pin[11] = CPU_LDS;
 81:Pin[12] = CPU_RW;
 82:Pin[17,18,20,21,22,24,25,27] = [SREG_IN0..7];
 83:
 84:/** Outputs **/
 85:Pin[4] = VGA_HSYNC;
 86:Pin[5] = VGA_VSYNC;
 87:Pin[29] = VRAM_LOW_CE;
 88:Pin[30] = VRAM_HIGH_CE;
 89:Pin[31] = VRAM_OE;          /* Could also be used for FRAM_OE - Consider CPU Access? */
 90:Pin[33] = VRAM_WE;
 91:Pin[48,46] = GRAPH_MODE0,GRAPH_MODE1;       /* 0 = TEXT, 1=GRAPHICS */
 92:
 93:
 94:
 95:/* 
 96:   Video Ram data bus input, RGB output, and internal lataches for data bus input.
 97:*/
 98:
 99:Pin [74,73,70,69,68,67,65,64,63,61,60,58,57,56,55,54]= [VMEM_SRCD0..15];
100:Pin [81,80]= [VRED_OUT0..1];
101:Pin [79,77]= [VGREEN_OUT0..1];
102:Pin [76,75]= [VBLUE_OUT0..1];
103:Pin [35,34]= [FONTSEL0..1];
104:
105:/* Address lines that go to the character rom for text mode.  */
106:Pin[40,39,37,36] = [FRAM_A0..3];         
107:

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

108:/* Signals back to the host CPU */
109:Pin[15] = CPU_VRAM_DTACK;
110:Pin[16] = VERT_SYNC_INTERRUPT;
111:
112:/* control line for CPU to Video RAM interface */
113:Pin[41] = SBUS_TO_VRAM_AD_OE;
114:Pin[44] = VGA_CONFIG_WRITE;
115:Pin[52,51,50] = [VADDR_MODE0..2];
116:
117:/* Pins to second CPLD 
118:    VGA_CONFIG_WRITE: Signal that the CPU is writing to the config register inside the address CPLD.
119:
120:    VADDR_MODE: 3 bit signal to tell the address generation CPLD what to do on the next clock cycle.
121:
122:     [VADDR_MODE0..2] - Address Increment Mode
123:        000  DO NOTHING   vaddr_mode_field:['d'0] 
124:        001  INCREMENT    vaddr_mode_field:['d'1] Increment Address by 1
125:        010  RESET_A6     vaddr_mode_field:['d'2] Reset Lower 6 bits of Address - For Text Mode to repeat a line (for char font)
126:        011  RESET_A6I    vaddr_mode_field:['d'3] Reset Lower 6 bits of Address, and increment remaining upper bits by 1.  (NEXT LINE)
127:        100  RESET_ALL    vaddr_mode_field:['d'4] Reset All Address Bits back to TOP
128:        101  RESET_ALL    vaddr_mode_field:['d'5] Reset All Address Bits back to TOP
129:        110  RESET_ALL    vaddr_mode_field:['d'6] Reset All Address Bits back to TOP
130:        111  RESET_ALL    vaddr_mode_field:['d'7] Reset All Address Bits back to TOP
131:                          vaddr_mode_field:['d'4..'d'7]
132:*/
133:
134:
135:
136:NODE [VMEM_SRC_LATCHED0..15];
137:NODE [HSYNC_COUNTER0..9];
138:NODE [VSYNC_COUNTER0..9];
139:NODE VSYNC_CLOCK_A,VSYNC_CLOCK_B;
140:NODE SREG_LOAD,SREG_SHIFT;
141:NODE VGA_BUSY,VGA_BUSY_CSLOCKED, CPU_VRAM_CS_CLOCKED , CPU_VRAM_ACCESS_ENABLED;
142:NODE RAM_OE;
143:NODE [SREG_D0..7];
144:
145:/*  ________________________________________________________________ */
146:/* Shift Register Implementation 
147:    SREG_Dx are the storage registers.  D7 is the output.
148:    SREG_LOAD is an active high signal to load from SREG_IN the 8 bit value
149:    SREG_SHIFT is an active high signal to shift from 0-->7 on clock.   
150:    SREG_LOAD overrides SREG_SHIFT.
151:    if neither SREG_LOAD or SREG_SHIFT are high the register value stays the same.
152:*/
153:
154:SREG_D0.d = (SREG_LOAD & SREG_IN0) # (!SREG_LOAD & !SREG_SHIFT & SREG_D0);
155:SREG_D1.d = (SREG_LOAD & SREG_IN1) # (!SREG_LOAD & SREG_SHIFT & SREG_D0) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D1 );
156:SREG_D2.d = (SREG_LOAD & SREG_IN2) # (!SREG_LOAD & SREG_SHIFT & SREG_D1) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D2 );
157:SREG_D3.d = (SREG_LOAD & SREG_IN3) # (!SREG_LOAD & SREG_SHIFT & SREG_D2) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D3 );
158:SREG_D4.d = (SREG_LOAD & SREG_IN4) # (!SREG_LOAD & SREG_SHIFT & SREG_D3) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D4 );
159:SREG_D5.d = (SREG_LOAD & SREG_IN5) # (!SREG_LOAD & SREG_SHIFT & SREG_D4) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D5 );
160:SREG_D6.d = (SREG_LOAD & SREG_IN6) # (!SREG_LOAD & SREG_SHIFT & SREG_D5) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D6 );
161:SREG_D7.d = (SREG_LOAD & SREG_IN7) # (!SREG_LOAD & SREG_SHIFT & SREG_D6) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D7 );

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

162:
163:SREG_D0.ck = CLK_25M;
164:SREG_D1.ck = CLK_25M;
165:SREG_D2.ck = CLK_25M;
166:SREG_D3.ck = CLK_25M;
167:SREG_D4.ck = CLK_25M;
168:SREG_D5.ck = CLK_25M;
169:SREG_D6.ck = CLK_25M;
170:SREG_D7.ck = CLK_25M;
171:
172:SREG_D0.ar = !VGA_RESET;
173:SREG_D1.ar = !VGA_RESET;
174:SREG_D2.ar = !VGA_RESET;
175:SREG_D3.ar = !VGA_RESET;
176:SREG_D4.ar = !VGA_RESET;
177:SREG_D5.ar = !VGA_RESET;
178:SREG_D6.ar = !VGA_RESET;
179:SREG_D7.ar = !VGA_RESET;
180:
181:
182:/*  ________________________________________________________________ */
183:
184:
185:/* 
186:    Video Out MUX:  In Text mode, pass thru the RGB _IN to _OUT if SREG_D7==1 and we are in the active region.
187:                    In Graphics mode, pass thru RGB _IN to +_OUT all of the time if we are in the active region. 
188:                    Active Region is RAM_OE.
189:    SRC Latch activated by CLK_25 as well as SR_LOAD.  SR_LOAD is used to both latch this data as well
190:    as latch data into the shift register.
191:
192:*/
193:
194:/* active high signal to latch new value from SRC */
195:
196:VMEM_SRC_LATCH_LOW = SREG_LOAD;
197:VMEM_SRC_LATCH_HIGH = SREG_LOAD;
198:
199:/* VMEM_SRC_LATCHED0..7 */
200:
201:VMEM_SRC_LATCHED0.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED0) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD0);
202:VMEM_SRC_LATCHED1.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED1) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD1);
203:VMEM_SRC_LATCHED2.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED2) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD2);
204:VMEM_SRC_LATCHED3.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED3) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD3);
205:VMEM_SRC_LATCHED4.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED4) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD4);
206:VMEM_SRC_LATCHED5.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED5) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD5);
207:VMEM_SRC_LATCHED6.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED6) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD6);
208:VMEM_SRC_LATCHED7.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED7) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD7);
209:
210:VMEM_SRC_LATCHED8.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED8) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD8);
211:VMEM_SRC_LATCHED9.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED9) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD9);
212:VMEM_SRC_LATCHED10.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED10) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD10);
213:VMEM_SRC_LATCHED11.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED11) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD11);
214:VMEM_SRC_LATCHED12.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED12) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD12);
215:VMEM_SRC_LATCHED13.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED13) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD13);

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

216:VMEM_SRC_LATCHED14.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED14) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD14);
217:VMEM_SRC_LATCHED15.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED15) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD15);
218:
219:[VMEM_SRC_LATCHED0..15].ck = CLK_25M;
220:[VMEM_SRC_LATCHED0..15].ar = !VGA_RESET;
221:
222:/* 
223:      output color signal 
224:      GRAPHMODE == 0 (Text Mode) , Shift Reg & Attrib bits (VMEM bits 8,9,10,11,12,13)
225:      GRAPHMODE == 1 (Graph Mode), VMEM bits. VDP_HORL switches between L and H pixel data.
226:*/
227:
228:VRED_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED8) 
229:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED8) # (!VDP_HORL & VMEM_SRC_LATCHED0)));
230:
231:VRED_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED9) 
232:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED9) # (!VDP_HORL & VMEM_SRC_LATCHED1)));
233:
234:VGREEN_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED10) 
235:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED10) # (!VDP_HORL & VMEM_SRC_LATCHED2)));
236:
237:VGREEN_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED11) 
238:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED11) # (!VDP_HORL & VMEM_SRC_LATCHED3)));
239:
240:VBLUE_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED12) 
241:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED12) # (!VDP_HORL & VMEM_SRC_LATCHED4)));
242:
243:VBLUE_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED13) 
244:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED13) # (!VDP_HORL & VMEM_SRC_LATCHED5)));
245:
246:FONTSEL0 = VMEM_SRC_LATCHED14;
247:FONTSEL1 = VMEM_SRC_LATCHED15;
248:
249:
250:/*
251:   VGA Config registers.  WRITE ONLY, BYTE WRITE ONLY.
252:      bit 0 = MODE, 0 for TXT, 1 for Graphics; 0 on RESET
253:      bit 1 = FONTSEL0   FONTSEL selects from 4 font libraries stored in the FONT ROM
254:      bit 2 = FONTSEL1
255:
256:      This register to clocked at the end of the write cycle with the deassertion of CS and R/W
257:
258:*/
259:
260:/*
261:   Access to VGA Config registers from CPU 
262:   CPU will assert /CPU_VGA_CFG_CS and /CPU_RW to indicate a write to the CGA config register.
263:   VGA_CONFIG_WRITE==1 when both CPU_CGA_CFG_CS and CPU_RW are asserted (==0). 
264:*/
265:
266:VGA_CONFIG_WRITE = !(CPU_VGA_CFG_CS # CPU_RW);
267:
268:/* VGA_BUSY is 1 when the VGA memory is bring used by the VGA interface */
269:

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 6

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

270:
271:FRAM_A0 = (!GRAPH_MODE0 & VSYNC_COUNTER0)
272:         # ((GRAPH_MODE0 & 'd'0));
273:FRAM_A1 = (!GRAPH_MODE0 & VSYNC_COUNTER1)
274:         # ((GRAPH_MODE0 & 'd'0));
275:FRAM_A2 = (!GRAPH_MODE0 & VSYNC_COUNTER2)
276:         # ((GRAPH_MODE0 & 'd'0));
277:FRAM_A3 = (!GRAPH_MODE0 & VSYNC_COUNTER3)
278:         # ((GRAPH_MODE0 & 'd'0));
279:
280:
281:/* Horizontal Sync 10 bit counter, 0-799.  HSYNC_ZERO is used to reset this counter so it loops from 799 back to 0 */
282:
283:HSYNC_COUNTER0.d = !HSYNC_COUNTER0 & HSYNC_ZERO;
284:HSYNC_COUNTER0.ck = CLK_25M;
285:HSYNC_COUNTER0.ar = !VGA_RESET;
286:
287:HSYNC_COUNTER1.d = ((HSYNC_COUNTER0&!HSYNC_COUNTER1) # (!HSYNC_COUNTER0&HSYNC_COUNTER1)) & HSYNC_ZERO;
288:HSYNC_COUNTER1.ck = CLK_25M;
289:HSYNC_COUNTER1.ar = !VGA_RESET;
290:
291:HSYNC_COUNTER2T = HSYNC_COUNTER0&HSYNC_COUNTER1;
292:HSYNC_COUNTER2.d = ((HSYNC_COUNTER2T&!HSYNC_COUNTER2) # (!HSYNC_COUNTER2T&HSYNC_COUNTER2)) & HSYNC_ZERO;
293:HSYNC_COUNTER2.ck = CLK_25M;
294:HSYNC_COUNTER2.ar = !VGA_RESET;
295:
296:HSYNC_COUNTER3T = HSYNC_COUNTER2T&HSYNC_COUNTER2;
297:HSYNC_COUNTER3.d = ((HSYNC_COUNTER3T&!HSYNC_COUNTER3) # (!HSYNC_COUNTER3T&HSYNC_COUNTER3)) & HSYNC_ZERO;
298:HSYNC_COUNTER3.ck = CLK_25M;
299:HSYNC_COUNTER3.ar = !VGA_RESET;
300:
301:HSYNC_COUNTER4T = HSYNC_COUNTER3T&HSYNC_COUNTER3;
302:HSYNC_COUNTER4.d = ((HSYNC_COUNTER4T&!HSYNC_COUNTER4) # (!HSYNC_COUNTER4T&HSYNC_COUNTER4)) & HSYNC_ZERO;
303:HSYNC_COUNTER4.ck = CLK_25M;
304:HSYNC_COUNTER4.ar = !VGA_RESET;
305:
306:HSYNC_COUNTER5T = HSYNC_COUNTER4T&HSYNC_COUNTER4;
307:HSYNC_COUNTER5.d = ((HSYNC_COUNTER5T&!HSYNC_COUNTER5) # (!HSYNC_COUNTER5T&HSYNC_COUNTER5)) & HSYNC_ZERO;
308:HSYNC_COUNTER5.ck = CLK_25M;
309:HSYNC_COUNTER5.ar = !VGA_RESET;
310:
311:HSYNC_COUNTER6T = HSYNC_COUNTER5T&HSYNC_COUNTER5;
312:HSYNC_COUNTER6.d = ((HSYNC_COUNTER6T&!HSYNC_COUNTER6) # (!HSYNC_COUNTER6T&HSYNC_COUNTER6)) & HSYNC_ZERO;
313:HSYNC_COUNTER6.ck = CLK_25M;
314:HSYNC_COUNTER6.ar = !VGA_RESET;
315:
316:HSYNC_COUNTER7T = HSYNC_COUNTER6T&HSYNC_COUNTER6;
317:HSYNC_COUNTER7.d = ((HSYNC_COUNTER7T&!HSYNC_COUNTER7) # (!HSYNC_COUNTER7T&HSYNC_COUNTER7)) & HSYNC_ZERO;
318:HSYNC_COUNTER7.ck = CLK_25M;
319:HSYNC_COUNTER7.ar = !VGA_RESET;
320:
321:HSYNC_COUNTER8T = HSYNC_COUNTER7T&HSYNC_COUNTER7;
322:HSYNC_COUNTER8.d = ((HSYNC_COUNTER8T&!HSYNC_COUNTER8) # (!HSYNC_COUNTER8T&HSYNC_COUNTER8)) & HSYNC_ZERO;
323:HSYNC_COUNTER8.ck = CLK_25M;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 7

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

324:HSYNC_COUNTER8.ar = !VGA_RESET;
325:
326:HSYNC_COUNTER9T = HSYNC_COUNTER8T&HSYNC_COUNTER8;
327:HSYNC_COUNTER9.d = ((HSYNC_COUNTER9T&!HSYNC_COUNTER9) # (!HSYNC_COUNTER9T&HSYNC_COUNTER9)) & HSYNC_ZERO;
328:HSYNC_COUNTER9.ck = CLK_25M;
329:HSYNC_COUNTER9.ar = !VGA_RESET;
330:
331:FIELD hsync_counter_field = [HSYNC_COUNTER9..0];
332:FIELD hsync_counter_3_field = [HSYNC_COUNTER2..0];
333:FIELD hsync_counter_4_field = [HSYNC_COUNTER3..0];
334:
335:/* 
336:   HSYNC_ZERO is 0 when we need to loop the counter.  This is Logical AND'ed with the other inputs to each
337:   counters .d value, so when we are at the loop location, the next location loaded will be 0.
338:   HSYNC_ZERO us normally at 1, and goes to 0 for 1 clock cycle ( CLK25 low to CLK25 low ), and that
339:   edge is also used to increment the vertical counters via VSYNC_CLOCK.
340:*/
341:
342:HSYNC_ZERO = !(hsync_counter_field:['d'799]);
343:
344:/* 
345:   The VSYNC_CLOCK signal is used to increment the V_SYNC counter at the end of each horizontal sync row.   
346:   The reason for two FFs is to first capture the HSYNC value (on the clock edge opposite of the counter itself changing)
347:   followed by a second FF to sync the V_SYNC increment with the rising edge of CLK_25M.   This allows both the H_SYNC and V_SYNC 
348:   counters to be used in logical operations that are clocked on the same clock signal (falling CLK_25M)
349:*/
350:
351:
352:VSYNC_CLOCK_A.d = !HSYNC_ZERO;
353:VSYNC_CLOCK_A.ck = !CLK_25M;
354:VSYNC_CLOCK_A.ar = !VGA_RESET;
355:
356:VSYNC_CLOCK_B.d = VSYNC_CLOCK_A;
357:VSYNC_CLOCK_B.ck = CLK_25M;
358:VSYNC_CLOCK_B.ar = !VGA_RESET;
359:
360:/* Vertical Sync 9 bit counter, 0-498.  VSYNC_ZERO is used to reset this counter so it loops from 498 back to 0 */
361:
362:VSYNC_COUNTER0.d = (!VSYNC_COUNTER0) & VSYNC_ZERO;
363:VSYNC_COUNTER0.ck = VSYNC_CLOCK_B;
364:VSYNC_COUNTER0.ar = !VGA_RESET;
365:
366:VSYNC_COUNTER1.d = ((VSYNC_COUNTER0&!VSYNC_COUNTER1) # (!VSYNC_COUNTER0&VSYNC_COUNTER1)) & VSYNC_ZERO;
367:VSYNC_COUNTER1.ck = VSYNC_CLOCK_B;
368:VSYNC_COUNTER1.ar = !VGA_RESET;
369:
370:VSYNC_COUNTER2T = VSYNC_COUNTER0&VSYNC_COUNTER1;
371:VSYNC_COUNTER2.d = ((VSYNC_COUNTER2T&!VSYNC_COUNTER2) # (!VSYNC_COUNTER2T&VSYNC_COUNTER2)) & VSYNC_ZERO;
372:VSYNC_COUNTER2.ck = VSYNC_CLOCK_B;
373:VSYNC_COUNTER2.ar = !VGA_RESET;
374:
375:VSYNC_COUNTER3T = VSYNC_COUNTER2T&VSYNC_COUNTER2;
376:VSYNC_COUNTER3.d = ((VSYNC_COUNTER3T&!VSYNC_COUNTER3) # (!VSYNC_COUNTER3T&VSYNC_COUNTER3)) & VSYNC_ZERO;
377:VSYNC_COUNTER3.ck = VSYNC_CLOCK_B;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 8

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

378:VSYNC_COUNTER3.ar = !VGA_RESET;
379:
380:VSYNC_COUNTER4T = VSYNC_COUNTER3T&VSYNC_COUNTER3;
381:VSYNC_COUNTER4.d = ((VSYNC_COUNTER4T&!VSYNC_COUNTER4) # (!VSYNC_COUNTER4T&VSYNC_COUNTER4)) & VSYNC_ZERO;
382:VSYNC_COUNTER4.ck = VSYNC_CLOCK_B;
383:VSYNC_COUNTER4.ar = !VGA_RESET;
384:
385:VSYNC_COUNTER5T = VSYNC_COUNTER4T&VSYNC_COUNTER4;
386:VSYNC_COUNTER5.d = ((VSYNC_COUNTER5T&!VSYNC_COUNTER5) # (!VSYNC_COUNTER5T&VSYNC_COUNTER5)) & VSYNC_ZERO;
387:VSYNC_COUNTER5.ck = VSYNC_CLOCK_B;
388:VSYNC_COUNTER5.ar = !VGA_RESET;
389:
390:VSYNC_COUNTER6T = VSYNC_COUNTER5T&VSYNC_COUNTER5;
391:VSYNC_COUNTER6.d = ((VSYNC_COUNTER6T&!VSYNC_COUNTER6) # (!VSYNC_COUNTER6T&VSYNC_COUNTER6)) & VSYNC_ZERO;
392:VSYNC_COUNTER6.ck = VSYNC_CLOCK_B;
393:VSYNC_COUNTER6.ar = !VGA_RESET;
394:
395:VSYNC_COUNTER7T = VSYNC_COUNTER6T&VSYNC_COUNTER6;
396:VSYNC_COUNTER7.d = ((VSYNC_COUNTER7T&!VSYNC_COUNTER7) # (!VSYNC_COUNTER7T&VSYNC_COUNTER7)) & VSYNC_ZERO;
397:VSYNC_COUNTER7.ck = VSYNC_CLOCK_B;
398:VSYNC_COUNTER7.ar = !VGA_RESET;
399:
400:VSYNC_COUNTER8T = VSYNC_COUNTER7T&VSYNC_COUNTER7;
401:VSYNC_COUNTER8.d = ((VSYNC_COUNTER8T&!VSYNC_COUNTER8) # (!VSYNC_COUNTER8T&VSYNC_COUNTER8)) & VSYNC_ZERO;
402:VSYNC_COUNTER8.ck = VSYNC_CLOCK_B;
403:VSYNC_COUNTER8.ar = !VGA_RESET;
404:
405:VSYNC_COUNTER9T = VSYNC_COUNTER8T&VSYNC_COUNTER8;
406:VSYNC_COUNTER9.d = ((VSYNC_COUNTER9T&!VSYNC_COUNTER9) # (!VSYNC_COUNTER9T&VSYNC_COUNTER9)) & VSYNC_ZERO;
407:VSYNC_COUNTER9.ck = VSYNC_CLOCK_B;
408:VSYNC_COUNTER9.ar = !VGA_RESET;
409:
410:FIELD vsync_counter_field = [VSYNC_COUNTER9..0];
411:FIELD vsync_counter_4_field = [VSYNC_COUNTER3..0];
412:
413:VSYNC_ZERO = !(vsync_counter_field:['d'524]);
414:
415:/* VSYNC_DISPLAY_ACTIVE == 1 when on an active output row */
416:VSYNC_DISPLAY_ACTIVE = (vsync_counter_field:[0..'d'479]);
417:
418:/* 
419:   VERT_SYNC_INTERRUPT is used to tell the CPU that we are entering the vertical refresh interval.
420:   VERY_SYNC_INTERRUPT goes to 1 during the active part of the display, and the falling edge indicates 
421:   entering the refresh interval
422: */
423:VERT_SYNC_INTERRUPT = VSYNC_DISPLAY_ACTIVE;
424:
425:/*  NOT USING
426:VGA_DISPLAY_ACTIVE.d = (hsync_counter_field:['d'8..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
427:VGA_DISPLAY_ACTIVE.ck = !CLK_25M;
428:VGA_DISPLAY_ACTIVE.ar = !VGA_RESET;
429:*/
430:
431:/* 

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 9

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

432:   RAM_OE is used by the VRAM CE ,OE, and WE lines to select when the video adapter is using VRAM.  
433:   It is active low, so ==0 indicates VRAM is being used by the video adapter 
434:*/
435:
436:RAM_OE.d = !((hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE));
437:RAM_OE.ck = !CLK_25M;
438:RAM_OE.ap = !VGA_RESET;
439:
440:VGA_BUSY.d =  ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
441:VGA_BUSY.ck = !CLK_25M;
442:VGA_BUSY.ar = !VGA_RESET;
443:
444:/* Control of VRAM */
445:/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle(including chip select), and ==1 when the VGA is in control */
446:
447:/* In graphics mode, we need to go between the low and high data values.  HC0 -> 0, HC1 -> 1 */
448:
449:VDP_HORL =  (GRAPH_MODE0 & HSYNC_COUNTER0 & !RAM_OE);
450:
451:VRAM_LOW_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_LDS );
452:VRAM_HIGH_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_UDS );
453:VRAM_OE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & !CPU_RW );
454:VRAM_WE = (CPU_VRAM_ACCESS_ENABLED # CPU_RW );
455:
456:SREG_LOAD.d = (hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]);
457:SREG_LOAD.ck = !CLK_25M;
458:SREG_LOAD.ar = !VGA_RESET;
459:
460:SREG_SHIFT.d = (hsync_counter_field:['d'7..'d'647] & vsync_counter_field:['d'0..'d'479]);
461:SREG_SHIFT.ck = !CLK_25M;
462:SREG_SHIFT.ar = !VGA_RESET;
463:
464:VGA_HSYNC.d = !(hsync_counter_field:['d'664..'d'759]);
465:VGA_HSYNC.ck = !CLK_25M;
466:VGA_HSYNC.ap = !VGA_RESET;
467:
468:VGA_VSYNC.d = !(vsync_counter_field:['d'490..'d'491]);
469:VGA_VSYNC.ck = !CLK_25M;
470:VGA_VSYNC.ar = !VGA_RESET;
471:
472:/*
473:      VGA_BUSY is a flag that indicates if the Video memory can be accessed by the CPU.  
474:         == 1 indicates the video controller is usig the memory
475:         == 0 indicates the memory is available for CPU access.
476:         This needs to be active outside of the video access hcount, and during the vertical
477:         refresh period. It needs a guard band around the start time to guarentee a CPU cycle can
478:         complete before the video side needs access.  
479:
480:         ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
481:
482:
483:      VGA_BUSY_CSLOCKED is a version of VGA_BUSY that is clocked at the start of a CPU
484:         access cycle.  It is used to guarentee that the video memory cannot become busy during
485:         the middle of a CPU access cycle.  As such you have to guarentee there is enough guard 

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 10

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

486:         time around VGA_BUSY to account for a full cpu cycle (250ns, or 7 pixle clocks)
487:         This signal is also used to trigger the SBUS_TO_VRAM_AD_OE output, which turns on the
488:         buffers that connect the CPU bus to the Video memory bus. SBUS_TO_VRAM_AD_OE in enabled
489:         when this value is 0 AND CPU_VGA_VRAM_CS is asserted (==0).   
490:
491:      CPU_VRAM_DTACK is the DTACK signal back to the CPU.  When it is 1, the CPU will add waitstates
492:         during an access until it goes to 0.  Once DTACK goes to 0, the CPU will complete the access cycle.
493:         This gate is clocked on CLK_25M, which guarentees a 19ns delay from when VGA_BUSY falls to 0.  Since the VRAM_AD_OE 
494:         is enabled as soon as VGA_BUSY falls, the address and data signals will have additional time to get to the VRAM.
495:         The VRAM OE/WE/CE signals should also be asserted using this same combinatorial. 
496:*/
497:
498:VGA_BUSY_CSLOCKED.d = VGA_BUSY;
499:VGA_BUSY_CSLOCKED.ck = !CPU_VGA_VRAM_CS;
500:VGA_BUSY_CSLOCKED.ar = !VGA_BUSY # !VGA_RESET;
501:
502:CPU_VRAM_CS_CLOCKED.d = CPU_VGA_VRAM_CS;
503:CPU_VRAM_CS_CLOCKED.ck = !CLK_25M;
504:CPU_VRAM_CS_CLOCKED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
505:
506:CPU_VRAM_ACCESS_ENABLED.d = VGA_BUSY_CSLOCKED # CPU_VRAM_CS_CLOCKED;
507:CPU_VRAM_ACCESS_ENABLED.ck = CLK_25M;
508:CPU_VRAM_ACCESS_ENABLED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
509:
510:CPU_VRAM_DTACK.d = CPU_VRAM_ACCESS_ENABLED;
511:CPU_VRAM_DTACK.ck = !CLK_25M;
512:CPU_VRAM_DTACK.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
513:
514:/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle, and ==1 when the VGA is in control */
515:
516:SBUS_TO_VRAM_AD_OE = CPU_VRAM_ACCESS_ENABLED;
517:
518:/* Address Mode Generation 
519:     Address Mode is controlled by the 3 bit field VADDR_MODE[0,1,2].   Since it is an encoded field
520:     we will generate the control variables for each condition, and use those to generate the final
521:     mode.
522:
523:     RESET_ALL = In text mode, do at end last line.
524:     RESET_L6 = In text mode -
525:
526:     [VADDR_MODE0..2] - Address Increment Mode
527:        000  DO NOTHING   vaddr_mode_field:['d'0] 
528:        001  INCREMENT    vaddr_mode_field:['d'1]
529:        010  RESET_A6     vaddr_mode_field:['d'2]
530:        011  RESET_A6I    vaddr_mode_field:['d'3]
531:        100  RESET_ALL    vaddr_mode_field:['d'4]
532:        101  RESET_ALL    vaddr_mode_field:['d'5]
533:        110  RESET_ALL    vaddr_mode_field:['d'6]
534:        111  RESET_ALL    vaddr_mode_field:['d'7]
535:                          vaddr_mode_field:['d'4..'d'7]
536:
537:*/
538:
539:VADDR_INCREMENT = (hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]);

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 11

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Tue Mar 14 17:50:19 2023

540:VADDR_RESET_ALL = (hsync_counter_field:['d'799] & vsync_counter_field:['d'524]);
541:VADDR_RESET_A6 =  (hsync_counter_field:['d'799] & vsync_counter_4_field:['d'0..'d'14]);
542:VADDR_RESET_A6I = (hsync_counter_field:['d'799] & vsync_counter_4_field:['d'15]);
543:VADDR_MODE0 = VADDR_RESET_A6I # VADDR_INCREMENT;
544:VADDR_MODE1 = VADDR_RESET_A6 # VADDR_RESET_A6I;
545:VADDR_MODE2 = VADDR_RESET_ALL;
546:
547:/*
548:
549:
550:Total dedicated input used:     2/4     (50%)
551:Total I/O pins used             59/64   (92%)
552:Total Logic cells used          96/128  (75%)
553:Total Flip-Flop used            56/128  (43%)
554:Total Foldback logic used       3/128   (2%)
555:Total Nodes+FB/MCells           97/128  (75%)
556:Total cascade used              2
557:Total input pins                36
558:Total output pins               25
559:Total Pts                       300
560:
561:
562:*/
563:
564:
565:
566:
567:



