Name	   DRAMARB;
PartNo   DRAMARB;
Date     05/28/2023;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1504ispplcc44;


/* 
   Version 1.1 - 3 node, with 1 node always at high priority.  Use case is for DRAM Refresh, since that should
*/



PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};

/** Inputs **/

Pin[2] = CLK_32M;                  /* Clock */
Pin[1] = SYS_RESET;                /* Active Low Reset */
Pin[12,14] = [REQ0..1];                  /* Active Low Request, clocked internaly on CLK+ edge */
Pin[16,17] = [GRANT0..1];                /* Active Low Grant, clocked output on CLK- edge */
Pin[24] = REFRESH_GRANT;
Pin[9,11] = [RAS0..1];
Pin[4,5,6,8] = [CAS0..3];
Pin[25,26] = CPU0_A1, CPU1_A1;
Pin[27,28] = CPU0_UDS, CPU1_UDS;
Pin[29,31] = CPU0_LDS, CPU1_LDS;


NODE [REQ_CLOCKED0..1];
NODE PE_BIAS;
NODE REFRESH_TIMER_RESET;
NODE [REFRESH_TIMER0..7];
NODE CLK_16M_INTERNAL;
NODE REFRESH_REQUESTED, REFRESH_COMPLETED, REFRESH_REQ_CLOCKED;
NODE CAS_PRE;
NODE REFRESH_COMPLETED_PRE0, REFRESH_COMPLETED_PRE1, REFRESH_COMPLETED_PRE2;
/* Internally generated 16Mhz clock used for the refresh timer */


/* SIMULATOR OUTPUTS */

Pin[33,34,36] = SIM_AS, SIM_DRAM_CS, SIM_RW;
Pin[37] = SIM_START_BUTTON;

NODE [SIM_S0..7];
NODE SIM_START_LATCH;

SIM_START_LATCH.d = 'b'0;
SIM_START_LATCH.ck = !SIM_START_BUTTON;
SIM_START_LATCH.ap = !SYS_RESET # !SIM_S7;


[SIM_S0..7].ck = CLK_32M;

/* S2 starts the /AS signal, and S2 is reset when S7 starts, which will stop the /AS signal. */

SIM_S0.ap = !SYS_RESET;
SIM_S1.ap = !SYS_RESET;
SIM_S2.ap = !SYS_RESET # !SIM_S7;
SIM_S3.ap = !SYS_RESET;
SIM_S4.ap = !SYS_RESET;
SIM_S5.ap = !SYS_RESET;
SIM_S6.ap = !SYS_RESET;
SIM_S7.ap = !SYS_RESET;

SIM_S0.d = SIM_START_LATCH;
SIM_S1.d = SIM_S0;
SIM_S2.d = SIM_S1;
SIM_S3.d = SIM_S2;
SIM_S4.d = SIM_S3;
SIM_S5.d = SIM_S4;
SIM_S6.d = SIM_S5;
SIM_S7.d = SIM_S6;

SIM_AS = SIM_S2;
SIM_DS = SIM_AS # !SYS_RESET;    /* The addition of the SYS_RESET should force SIM_DS to be about 7ns behind SIM_AS */


CLK_16M_INTERNAL.d = !CLK_16M_INTERNAL;
CLK_16M_INTERNAL.ck = CLK_32M;
CLK_16M_INTERNAL.ar = !SYS_RESET;

/* 
    Clocking the incoming access request for each CPU, as well as the request from the REFRESH generator.
    All three of these are clocked on the falling of CLK32M.   These go into the priority encoder and the 
    output of the priority encoder (the GRANT signals) are clocked on the rising edge of CLK32M.
 */
REQ_CLOCKED0.d = REQ0;
REQ_CLOCKED1.d = REQ1;
[REQ_CLOCKED0..1].ck = !CLK_32M;
[REQ_CLOCKED0..1].ap = !SYS_RESET;

REFRESH_REQ_CLOCKED.ck = !CLK_32M;
REFRESH_REQ_CLOCKED.d = REFRESH_REQUESTED;
REFRESH_REQ_CLOCKED.ap = !SYS_RESET;


/* 
    The priority encoder takes the clocked request above and picks a winner.  If the REFRESH request is active it always wins,
    but between the two CPU request the winner is alternted by a 'BIAS' flag.  That BIAS flag alternates between 0 and 1, with
    that BIAS applied to pick the winner.  The BIAS flag changes with the falling edge of a signal called 'GRANT_ACTIVE', 
    and that signal is a combination all of the GRANT flags, thus is set to 0 whenever any access grant happens. 
*/

PE_BIAS.d = !PE_BIAS;
PE_BIAS.ck = !GRANT_ACTIVE;        /* Flip the PE_BIAS each time we start a new grant cycle */
PE_BIAS.ar = !SYS_RESET;

GRANT_ACTIVE = GRANT0 & GRANT1 & REFRESH_GRANT;   /* Active low signal that there is a active grant of access from 1 of 3 sources */

REFRESH_OUT = REFRESH_REQ_CLOCKED;            /* refresh requests always win */
PE_OUT_0 = ( !REFRESH_REQ_CLOCKED # PE_BIAS # REQ_CLOCKED0) &                     /* if BIAS is towards input 0, set output0 if input0 is set */
           ( !REFRESH_REQ_CLOCKED # !PE_BIAS # (REQ_CLOCKED0 # !REQ_CLOCKED1));  /* if BIAS is towards input 1, set output0 if input0 is set AND input 1 is not */
PE_OUT_1 = ( !REFRESH_REQ_CLOCKED # !PE_BIAS # REQ_CLOCKED1) &                    /* if BIAS is towards input 1, set output1 if input1 is set */
           ( !REFRESH_REQ_CLOCKED # PE_BIAS # (REQ_CLOCKED1 # !REQ_CLOCKED0));   /* if BIAS is towards input 0, set output1 if input1 is set AND input 0 is not */
          
REFRESH_GRANT.d = ( !GRANT_ACTIVE & REFRESH_GRANT ) #    /* If a grant is active, don't change output state */
          ( GRANT_ACTIVE & REFRESH_OUT );           /* If a grant is not active, grab the output from the priority encoder */
REFRESH_GRANT.ap = REFRESH_REQUESTED # !REFRESH_COMPLETED # !SYS_RESET;
REFRESH_GRANT.ck = CLK_32M;

GRANT0.d = ( !GRANT_ACTIVE & GRANT0 ) #        /* If a grant is active, don't change output state */
          ( GRANT_ACTIVE & PE_OUT_0 );         /* If a grant is not active, grab the output from the priority encoder */
GRANT0.ap = REQ0 # !SYS_RESET;

GRANT1.d = ( !GRANT_ACTIVE & GRANT1 ) #        /* If a grant is active, don't change output state */
          ( GRANT_ACTIVE & PE_OUT_1 );         /* If a grant is not active, grab the output from the priority encoder */       
GRANT1.ap = REQ1 # !SYS_RESET;
[GRANT0..1].ck = CLK_32M;


/* 
   REFRESH REQUESTED is a latch that is set to 0 when a refresh is needed, and cleared back to 1 once the refresh has
   occured.   REFRESH_COMPLETED should be set to 1 when the refresh is completed.
*/

REFRESH_REQUESTED.d = 'b'1;  // disabled
REFRESH_REQUESTED.ck = REFRESH_TIMER7;
REFRESH_REQUESTED.ap = !REFRESH_COMPLETED # !SYS_RESET;

/* 
   REFRESH_COMPLETED is a tree of gates that create a delay from the start to the end of the refresh cycle.

*/

REFRESH_COMPLETED_PRE0.d = REFRESH_GRANT;
REFRESH_COMPLETED_PRE0.ck = !CLK_32M;
REFRESH_COMPLETED_PRE0.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED_PRE1.d = REFRESH_COMPLETED_PRE0;
REFRESH_COMPLETED_PRE1.ck = !CLK_32M;
REFRESH_COMPLETED_PRE1.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED_PRE2.d = REFRESH_COMPLETED_PRE1;
REFRESH_COMPLETED_PRE2.ck = !CLK_32M;
REFRESH_COMPLETED_PRE2.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED.d = REFRESH_COMPLETED_PRE2;
REFRESH_COMPLETED.ck = !CLK_32M;
REFRESH_COMPLETED.ap = REFRESH_REQUESTED # !SYS_RESET;


/* RAS, CAS, RW, and AB for DRAM access */

// MEMORY_ACCESS_ACTIVE is zero if there is an active memory DRAM access cycle in progress.
MEMORY_ACCESS_GRANT_ACTIVE = (GRANT0 & GRANT1);
REFRESH_ACCESS_GRANT_ACTIVE = REFRESH_GRANT;

[RAS0..1].ck = !CLK_32M;
[RAS0..1].ap = ((!GRANT0) & REQ0) # ((!GRANT1) & REQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET;     // If the memory access granted ends, reset the RAS lines
RAS0.d = ( GRANT0 # CPU0_A1 ) & ( GRANT1 # CPU1_A1);
RAS1.d = ( GRANT0 # !CPU0_A1 ) & ( GRANT1 # !CPU1_A1);

CAS_PRE.d = MEMORY_ACCESS_GRANT_ACTIVE;
CAS_PRE.ck = !CLK_32M;
CAS_PRE.ap = ((!GRANT0) & REQ0) # ((!GRANT1) & REQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 

[CAS0..3].ck = !CLK_32M;
[CAS0..3].ap = ((!GRANT0) & REQ0) # ((!GRANT1) & REQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 

CAS0.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS1.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS2.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS3.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_UDS) & (REFRESH_GRANT ));


/* REFRESH TIMER for generating REFRESH REQUESTS */

/* 
   8 bit counter for refresh time.  This is built with 2x 4 bit counters that are chained 
   together.  In order to get a 15us cycle, this counter is preset to 0x08 on 'reset', and counts
   up to 128.  At 128 the REFRESH_REQUESTED event is triggered and the counter is 'reset' back to
   0x08.  The produces an event every 15us with an 8MHz clock.   

   If the clock rate is not 32MHz for the core input, this will need to be adjusted.

   The REFESH_TMER_RESET flip flop is used to produce a 1 clock cycle long reset signal once the 
   counter reaches 128 (highest bit set).  The output of that flipflop resets the counter value to 
   0x08.
*/

REFRESH_TIMER_RESET.d = REFRESH_TIMER7;
REFRESH_TIMER_RESET.ck = CLK_32M;
REFRESH_TIMER_RESET.ar = !SYS_RESET;

REFRESH_TIMER0.d = !REFRESH_TIMER0;
REFRESH_TIMER1.d = REFRESH_TIMER0 $ REFRESH_TIMER1;
REFRESH_TIMER2.d = ( REFRESH_TIMER2 & !REFRESH_TIMER0 )
                    # ( REFRESH_TIMER2 & !REFRESH_TIMER1 )
                    # ( !REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );
REFRESH_TIMER3.d = ( REFRESH_TIMER3 & !REFRESH_TIMER2 )
                    # ( REFRESH_TIMER3 & !REFRESH_TIMER0 )
                    # ( REFRESH_TIMER3 & !REFRESH_TIMER1 )
                    # ( !REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );

REFRESH_TIMER4.d = !REFRESH_TIMER4;
REFRESH_TIMER5.d = REFRESH_TIMER4 $ REFRESH_TIMER5;
REFRESH_TIMER6.d = ( REFRESH_TIMER6 & !REFRESH_TIMER4 )
                    # ( REFRESH_TIMER6 & !REFRESH_TIMER5 )
                    # ( !REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );
REFRESH_TIMER7.d = ( REFRESH_TIMER7 & !REFRESH_TIMER6 )
                    # ( REFRESH_TIMER7 & !REFRESH_TIMER4 )
                    # ( REFRESH_TIMER7 & !REFRESH_TIMER5 )
                    # ( !REFRESH_TIMER7 & REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );

/* This should normally be CLK_8M, but on the proto board we are starting with a 16MHz OSC and an
8MHz CPU Clock, this CLK_16M is actually Mhz */
/*[REFRESH_TIMER0..3].ck = CLK_8M;*/
[REFRESH_TIMER0..3].ck = CLK_16M_INTERNAL;
[REFRESH_TIMER4..7].ck = !(REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0);

/* 	
	At reset we want to set all bits to 0 except bit 3, which is the same as loading 0x08 into the counter.
	From 0x08 to 0x80 will give is the correct time period of 15us.
*/

[REFRESH_TIMER0..2].ar = REFRESH_TIMER_RESET # !SYS_RESET;
[REFRESH_TIMER4..7].ar = REFRESH_TIMER_RESET # !SYS_RESET;
REFRESH_TIMER3.ap = REFRESH_TIMER_RESET # !SYS_RESET;




/*
Total dedicated input used:	2/4 	(50%)
Total I/O pins used		19/32 	(59%)
Total Logic cells used 		32/64 	(50%)
Total Flip-Flop used 		29/64 	(45%)
Total Foldback logic used 	10/64 	(15%)
Total Nodes+FB/MCells 		40/64 	(62%)
Total cascade used 		2
Total input pins 		12
Total output pins 		9
Total Pts 			110


Final global control pins assignment (if applicable)...
-------------------------------------------------------
CLK_32M assigned to pin  43
SYS_RESET assigned to pin  1



Performing input pin pre-assignments ...
------------------------------------
CLK_32M assigned to pin  43
SYS_RESET assigned to pin  1

Attempt to place floating signals ...
------------------------------------
REQ_CLOCKED0 is placed at feedback node 601 (MC 1)
REQ_CLOCKED1 is placed at feedback node 602 (MC 2)
RAS1 is placed at pin 11 (MC 3)
RAS0 is placed at pin 9 (MC 4)
CAS2 is placed at pin 8 (MC 5)
REFRESH_TIMER_RESET is placed at feedback node 606 (MC 6)
CAS_PRE is placed at feedback node 607 (MC 7)
TDI is placed at pin 7 (MC 8)
PE_BIAS is placed at feedback node 608 (MC 8)
REFRESH_TIMER4 is placed at feedback node 609 (MC 9)
FB_163 is placed at foldback expander node 309 (MC 9)
REFRESH_TIMER5 is placed at feedback node 610 (MC 10)
FB_162 is placed at foldback expander node 310 (MC 10)
CAS0 is placed at pin 6 (MC 11)
FB_161 is placed at foldback expander node 311 (MC 11)
Com_Ctrl_155 is placed at foldback expander node 312 (MC 12)
REFRESH_TIMER7 is placed at feedback node 613 (MC 13)
Com_Ctrl_154 is placed at foldback expander node 313 (MC 13)
GRANT0 is placed at pin 5 (MC 14)
REFRESH_TIMER6 is placed at feedback node 615 (MC 15)
GRANT1 is placed at pin 4 (MC 16)
REQ1 is placed at pin 21 (MC 17)
REFRESH_COMPLETED_PRE2 is placed at feedback node 618 (MC 18)
REFRESH_REQ_CLOCKED is placed at feedback node 619 (MC 19)
CLK_16M_INTERNAL is placed at feedback node 620 (MC 20)
REFRESH_COMPLETED_PRE0 is placed at feedback node 621 (MC 21)
REFRESH_COMPLETED_PRE1 is placed at feedback node 622 (MC 22)
REFRESH_COMPLETED is placed at feedback node 623 (MC 23)
REFRESH_GRANT is placed at pin 17 (MC 24)
CAS3 is placed at pin 16 (MC 25)
REFRESH_REQUESTED is placed at feedback node 626 (MC 26)
REFRESH_TIMER0 is placed at feedback node 627 (MC 27)
FB_160 is placed at foldback expander node 327 (MC 27)
REFRESH_TIMER1 is placed at feedback node 628 (MC 28)
FB_159 is placed at foldback expander node 328 (MC 28)
REFRESH_TIMER2 is placed at feedback node 629 (MC 29)
CAS1 is placed at pin 14 (MC 30)
FB_158 is placed at foldback expander node 330 (MC 30)
Com_Ctrl_156 is placed at foldback expander node 331 (MC 31)
TMS is placed at pin 13 (MC 32)
REFRESH_TIMER3 is placed at feedback node 632 (MC 32)
Com_Ctrl_155 is placed at foldback expander node 332 (MC 32)
REQ0 is placed at pin 24 (MC 33)
CPU0_LDS is placed at pin 25 (MC 35)
CPU0_A1 is placed at pin 26 (MC 36)
CPU1_A1 is placed at pin 27 (MC 37)
CPU0_UDS is placed at pin 28 (MC 40)
TCK is placed at pin 32 (MC 48)
Com_Ctrl_157 is placed at feedback node 648 (MC 48)
TDO is placed at pin 38 (MC 56)

                                                                 
                                                                 
                                                                 
                                 S                               
                                 Y                               
                                 S    C                          
                     G  G        _    L                          
                     R  R        R    K                          
                  C  A  A        E    _                          
                  A  N  N  V     S    3  G                       
                  S  T  T  C     E    2  N                       
                  0  0  1  C     T    M  D                       
               ____________________________________              
              /   6  5  4  3  2  1 44 43 42 41 40  \             
         TDI |  7                                39 |            
        CAS2 |  8                                38 | TDO        
        RAS0 |  9                                37 |            
         GND | 10                                36 |            
        RAS1 | 11                                35 | VCC        
             | 12            ATF1504             34 |            
         TMS | 13          44-Lead PLCC          33 |            
        CAS1 | 14                                32 | TCK        
         VCC | 15                                31 |            
        CAS3 | 16                                30 | GND        
EFRESH_GRANT | 17                                29 |            
             |   18 19 20 21 22 23 24 25 26 27 28   |            
              \____________________________________/             
                          R  G  V  R  C  C  C  C                 
                          E  N  C  E  P  P  P  P                 
                          Q  D  C  Q  U  U  U  U                 
                          1        0  0  0  1  0                 
                                      _  _  _  _                 
                                      L  A  A  U                 
                                      D  1  1  D                 
                                      S        S    

*/



