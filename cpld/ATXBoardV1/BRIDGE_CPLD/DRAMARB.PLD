Name	   DRAMARB;
PartNo   DRAMARB;
Date     05/28/2023;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1504ispplcc44;


/* 
   Version 1.1 - 3 node, with 1 node always at high priority.  Use case is for DRAM Refresh, since that should
*/

PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};

/** Pins that will be exposed in the final design  **/

// INPUTS
Pin[2] = CLK_32M;                  /* Clock */
Pin[1] = SYS_RESET;                /* Active Low Reset */
Pin[12,14] = [AREQ0..1];                  /* Active Low Request, clocked internaly on CLK+ edge */
Pin[25,26] = CPU0_A1, CPU1_A1;
Pin[27,28] = CPU0_UDS, CPU1_UDS;
Pin[29,31] = CPU0_LDS, CPU1_LDS;
Pin[28] = CPU0_RW;
Pin     = CPU1_RW;

// OUTPUTS
Pin[9,11] = [RAS0..1];
Pin[4,5,6,8] = [CAS0..3];
Pin[21,20] = DRAM_RW, DRAM_AB;
Pin[18,19] = CPU0_DRAM_DTACK, CPU1_DRAM_DTACK;



Pin[16,17] = [GRANT0..1];                /* Active Low Grant, clocked output on CLK- edge */

/* Pins that are being exposed to enable debugging */
Pin = REFRESH_GRANT;
Pin = CLK_16M_INTERNAL;

NODE [REQ_CLOCKED0..1];
NODE PE_BIAS;
NODE REFRESH_TIMER_RESET;
NODE [REFRESH_TIMER0..7];
//NODE CLK_16M_INTERNAL;
NODE REFRESH_REQUESTED, REFRESH_COMPLETED, REFRESH_REQ_CLOCKED;
NODE CAS_PRE;
NODE REFRESH_COMPLETED_PRE0, REFRESH_COMPLETED_PRE1, REFRESH_COMPLETED_PRE2;
/* Internally generated 16Mhz clock used for the refresh timer */

CLK_16M_INTERNAL.d = !CLK_16M_INTERNAL;
CLK_16M_INTERNAL.ck = CLK_32M;
CLK_16M_INTERNAL.ar = !SYS_RESET;

/* 
    Clocking the incoming access request for each CPU, as well as the request from the REFRESH generator.
    All three of these are clocked on the falling of CLK32M.   These go into the priority encoder and the 
    output of the priority encoder (the GRANT signals) are clocked on the rising edge of CLK32M.
 */
REQ_CLOCKED0.d = AREQ0;
REQ_CLOCKED1.d = AREQ1;
[REQ_CLOCKED0..1].ck = !CLK_32M;
[REQ_CLOCKED0..1].ap = !SYS_RESET;

REFRESH_REQ_CLOCKED.ck = !CLK_32M;
REFRESH_REQ_CLOCKED.d = REFRESH_REQUESTED;
REFRESH_REQ_CLOCKED.ap = !SYS_RESET;


/* 
    The priority encoder takes the clocked request above and picks a winner.  If the REFRESH request is active it always wins,
    but between the two CPU request the winner is alternted by a 'BIAS' flag.  That BIAS flag alternates between 0 and 1, with
    that BIAS applied to pick the winner.  The BIAS flag changes with the falling edge of a signal called 'GRANT_ACTIVE', 
    and that signal is a combination all of the GRANT flags, thus is set to 0 whenever any access grant happens. 
*/
//
PE_BIAS.d = !PE_BIAS;
PE_BIAS.ck = !GRANT_ACTIVE;        /* Flip the PE_BIAS each time we start a new grant cycle */
PE_BIAS.ar = !SYS_RESET;

GRANT_ACTIVE = GRANT0 & GRANT1 & REFRESH_GRANT;   /* Active low signal that there is a active grant of access from 1 of 3 sources */

PE_REFRESH_OUT = REFRESH_REQ_CLOCKED;            /* refresh requests always win */
PE_OUT_0 = ( REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # PE_BIAS ) & 
           ( REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # !REQ_CLOCKED1 # !PE_BIAS );                             /* if BIAS is towards input 0, set output0 if input0 is set */
                                /* if BIAS is towards input 1, set output0 if input0 is set AND input 1 is not */
PE_OUT_1 = ( REQ_CLOCKED1 # !REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # PE_BIAS ) &
           ( REQ_CLOCKED1 # !REFRESH_REQ_CLOCKED # !PE_BIAS ) ;   /* if BIAS is towards input 0, set output1 if input1 is set AND input 0 is not */
          
         
REFRESH_GRANT.d = ( !GRANT_ACTIVE & REFRESH_GRANT ) #          /* If a grant is active, don't change output state */
                  ( GRANT_ACTIVE & PE_REFRESH_OUT );           /* If a grant is not active, grab the output from the priority encoder */
REFRESH_GRANT.ap = REFRESH_REQUESTED # !REFRESH_COMPLETED # !SYS_RESET;
REFRESH_GRANT.ck = CLK_32M;

//GRANT0.d = ( !GRANT_ACTIVE & GRANT0 ) #        /* If a grant is active, don't change output state */
//          ( GRANT_ACTIVE & PE_OUT_0 );         /* If a grant is not active, grab the output from the priority encoder */


GRANT0.D =  ( !GRANT_ACTIVE & GRANT0 ) #  
            ( GRANT_ACTIVE & PE_OUT_0 );
GRANT0.AP = AREQ0 # !SYS_RESET;
GRANT0.CK = CLK_32M;

GRANT1.d =  ( !GRANT_ACTIVE & GRANT1 ) #  
            ( GRANT_ACTIVE & PE_OUT_1 );         /* If a grant is not active, grab the output from the priority encoder */       
GRANT1.ap = AREQ1 # !SYS_RESET;
GRANT1.ck = CLK_32M;

CPU0_DRAM_DTACK = GRANT0;
CPU1_DRAM_DTACK = GRANT1;

/* 
   REFRESH REQUESTED is a latch that is set to 0 when a refresh is needed, and cleared back to 1 once the refresh has
   occured.   REFRESH_COMPLETED should be set to 1 when the refresh is completed.
*/

REFRESH_REQUESTED.d = 'b'0;  // disabled REFRESH  THIS SHOULD BE 0 TO ENABLE REFRESH TO HAPPEN.
REFRESH_REQUESTED.ck = REFRESH_TIMER7;
REFRESH_REQUESTED.ap = !REFRESH_COMPLETED # !SYS_RESET;

/* 
   REFRESH_COMPLETED is a tree of gates that create a delay from the start to the end of the refresh cycle.

*/

REFRESH_COMPLETED_PRE0.d = REFRESH_GRANT;
REFRESH_COMPLETED_PRE0.ck = !CLK_32M;
REFRESH_COMPLETED_PRE0.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED_PRE1.d = REFRESH_COMPLETED_PRE0;
REFRESH_COMPLETED_PRE1.ck = !CLK_32M;
REFRESH_COMPLETED_PRE1.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED_PRE2.d = REFRESH_COMPLETED_PRE1;
REFRESH_COMPLETED_PRE2.ck = !CLK_32M;
REFRESH_COMPLETED_PRE2.ap = REFRESH_REQUESTED # !SYS_RESET;

REFRESH_COMPLETED.d = REFRESH_COMPLETED_PRE2;
REFRESH_COMPLETED.ck = !CLK_32M;
REFRESH_COMPLETED.ap = REFRESH_REQUESTED # !SYS_RESET;


/* RAS, CAS, RW, and AB for DRAM access */
// MEMORY_ACCESS_ACTIVE is zero if there is an active memory DRAM access cycle in progress.

MEMORY_ACCESS_GRANT_ACTIVE = (GRANT0 & GRANT1);
REFRESH_ACCESS_GRANT_ACTIVE = REFRESH_GRANT;

[RAS0..1].ck = !CLK_32M;
[RAS0..1].ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET;     // If the memory access granted ends, reset the RAS lines
RAS0.d = ( GRANT0 # CPU0_A1 ) & ( GRANT1 # CPU1_A1) & ( REFRESH_GRANT # CAS0 );
RAS1.d = ( GRANT0 # !CPU0_A1 ) & ( GRANT1 # !CPU1_A1)  & ( REFRESH_GRANT # CAS0 );

CAS_PRE.d = MEMORY_ACCESS_GRANT_ACTIVE;
CAS_PRE.ck = !CLK_32M;
CAS_PRE.ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 

[CAS0..3].ck = !CLK_32M;
[CAS0..3].ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 

CAS0.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS1.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS2.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
CAS3.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_UDS) & (REFRESH_GRANT ));

/* The DRAM R/W signal will mirror the CPU_RW signal if we are doing a memory access.  If we are doing a refresh 
   cycle, it will be fixed at 1 */

DRAM_RW = (!GRANT0 & CPU0_RW) # (!GRANT1 & CPU1_RW) # MEMORY_ACCESS_GRANT_ACTIVE; 

/* 
   DRAM AB selects either the row address or the col address going to the memory.  1=ROW, 1=COL.  It is 1 at reset and held at one if
   MEMORY_ACCESS_GRANT_ACTIVE is 1.  As soon as a memory access cycle starts, it is unlocked and will toggle to 0 once one of the two RAS 
   signals goes to zero.  That puts the AB signal about 7ns behind the RAS signal, and the actual 2:1 mux delay will add another 10-12ns of
   delay.  That is just enough to get the COL address to the memory before the CAS signals goes to zero.
*/
DRAM_AB.d = 'b'0;
DRAM_AB.ck = !RAS0 # !RAS1;
DRAM_AB.ap = MEMORY_ACCESS_GRANT_ACTIVE # !SYS_RESET;



/* REFRESH TIMER for generating REFRESH REQUESTS */

/* 
   8 bit counter for refresh time.  This is built with 2x 4 bit counters that are chained 
   together.  In order to get a 15us cycle, this counter is preset to 0x08 on 'reset', and counts
   up to 128.  At 128 the REFRESH_REQUESTED event is triggered and the counter is 'reset' back to
   0x08.  The produces an event every 15us with an 8MHz clock.   

   If the clock rate is not 32MHz for the core input, this will need to be adjusted.

   The REFESH_TMER_RESET flip flop is used to produce a 1 clock cycle long reset signal once the 
   counter reaches 128 (highest bit set).  The output of that flipflop resets the counter value to 
   0x08.
*/

REFRESH_TIMER_RESET.d = REFRESH_TIMER7;
REFRESH_TIMER_RESET.ck = CLK_32M;
REFRESH_TIMER_RESET.ar = !SYS_RESET;

REFRESH_TIMER0.d = !REFRESH_TIMER0;
REFRESH_TIMER1.d = REFRESH_TIMER0 $ REFRESH_TIMER1;
REFRESH_TIMER2.d = ( REFRESH_TIMER2 & !REFRESH_TIMER0 )
                    # ( REFRESH_TIMER2 & !REFRESH_TIMER1 )
                    # ( !REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );
REFRESH_TIMER3.d = ( REFRESH_TIMER3 & !REFRESH_TIMER2 )
                    # ( REFRESH_TIMER3 & !REFRESH_TIMER0 )
                    # ( REFRESH_TIMER3 & !REFRESH_TIMER1 )
                    # ( !REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );

REFRESH_TIMER4.d = !REFRESH_TIMER4;
REFRESH_TIMER5.d = REFRESH_TIMER4 $ REFRESH_TIMER5;
REFRESH_TIMER6.d = ( REFRESH_TIMER6 & !REFRESH_TIMER4 )
                    # ( REFRESH_TIMER6 & !REFRESH_TIMER5 )
                    # ( !REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );
REFRESH_TIMER7.d = ( REFRESH_TIMER7 & !REFRESH_TIMER6 )
                    # ( REFRESH_TIMER7 & !REFRESH_TIMER4 )
                    # ( REFRESH_TIMER7 & !REFRESH_TIMER5 )
                    # ( !REFRESH_TIMER7 & REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );


/* This should normally be CLK_8M, but on the proto board we are starting with a 16MHz OSC and an
8MHz CPU Clock, this CLK_16M is actually Mhz */
/*[REFRESH_TIMER0..3].ck = CLK_8M;*/

[REFRESH_TIMER0..3].ck = CLK_16M_INTERNAL;
[REFRESH_TIMER4..7].ck = !(REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0);

/* 	
	At reset we want to set all bits to 0 except bit 3, which is the same as loading 0x08 into the counter.
	From 0x08 to 0x80 will give is the correct time period of 15us.
*/

[REFRESH_TIMER0..2].ar = REFRESH_TIMER_RESET # !SYS_RESET;
[REFRESH_TIMER4..7].ar = REFRESH_TIMER_RESET # !SYS_RESET;
REFRESH_TIMER3.ap = REFRESH_TIMER_RESET # !SYS_RESET;




/*

Total dedicated input used:	2/4 	(50%)
Total I/O pins used		26/32 	(81%)
Total Logic cells used 		37/64 	(57%)
Total Flip-Flop used 		30/64 	(46%)
Total Foldback logic used 	12/64 	(18%)
Total Nodes+FB/MCells 		47/64 	(73%)
Total cascade used 		2
Total input pins 		14
Total output pins 		14
Total Pts 			123


Final global control pins assignment (if applicable)...
-------------------------------------------------------
CLK_32M assigned to pin  2
SYS_RESET assigned to pin  1



Performing input pin pre-assignments ...
------------------------------------
CLK_32M assigned to pin  2
SYS_RESET assigned to pin  1
DRAM_AB.AP equation needs patching.
1 control eqution need patching

Attempt to place floating signals ...
------------------------------------
AREQ0 is placed at pin 12 (MC 1)
REFRESH_COMPLETED_PRE0 is placed at feedback node 601 (MC 1)
PE_BIAS is placed at feedback node 602 (MC 2)
RAS1 is placed at pin 11 (MC 3)
RAS0 is placed at pin 9 (MC 4)
CAS3 is placed at pin 8 (MC 5)
REFRESH_TIMER4 is placed at feedback node 606 (MC 6)
REFRESH_TIMER5 is placed at feedback node 607 (MC 7)
TDI is placed at pin 7 (MC 8)
REFRESH_TIMER2 is placed at feedback node 608 (MC 8)
REFRESH_TIMER7 is placed at feedback node 610 (MC 10)
CAS2 is placed at pin 6 (MC 11)
FB_171 is placed at foldback expander node 311 (MC 11)
FB_168 is placed at foldback expander node 312 (MC 12)
REFRESH_TIMER3 is placed at feedback node 613 (MC 13)
Com_Ctrl_166 is placed at foldback expander node 313 (MC 13)
CAS1 is placed at pin 5 (MC 14)
Com_Ctrl_165 is placed at foldback expander node 314 (MC 14)
REFRESH_TIMER6 is placed at feedback node 615 (MC 15)
CAS0 is placed at pin 4 (MC 16)
Com_Ctrl_164 is placed at foldback expander node 316 (MC 16)
DRAM_RW is placed at pin 21 (MC 17)
REQ_CLOCKED0 is placed at feedback node 618 (MC 18)
DRAM_AB is placed at pin 20 (MC 19)
CPU1_DRAM_DTACK is placed at pin 19 (MC 20)
CPU0_DRAM_DTACK is placed at pin 18 (MC 21)
REQ_CLOCKED1 is placed at feedback node 622 (MC 22)
REFRESH_REQ_CLOCKED is placed at feedback node 623 (MC 23)
GRANT1 is placed at pin 17 (MC 24)
GRANT0 is placed at pin 16 (MC 25)
DRAM_AB.AP is placed at feedback node 626 (MC 26)
REFRESH_COMPLETED_PRE1 is placed at feedback node 627 (MC 27)
REFRESH_COMPLETED_PRE2 is placed at feedback node 628 (MC 28)
FB_174 is placed at foldback expander node 328 (MC 28)
REFRESH_COMPLETED is placed at feedback node 629 (MC 29)
FB_173 is placed at foldback expander node 329 (MC 29)
AREQ1 is placed at pin 14 (MC 30)
REFRESH_TIMER0 is placed at feedback node 630 (MC 30)
FB_172 is placed at foldback expander node 330 (MC 30)
Com_Ctrl_167 is placed at feedback node 631 (MC 31)
Com_Ctrl_166 is placed at foldback expander node 331 (MC 31)
TMS is placed at pin 13 (MC 32)
REFRESH_TIMER1 is placed at feedback node 632 (MC 32)
Com_Ctrl_165 is placed at foldback expander node 332 (MC 32)
CLK_16M_INTERNAL is placed at pin 24 (MC 33)
CPU0_A1 is placed at pin 25 (MC 35)
CPU1_A1 is placed at pin 26 (MC 36)
CPU0_UDS is placed at pin 27 (MC 37)
CPU0_RW is placed at pin 28 (MC 40)
CPU0_LDS is placed at pin 29 (MC 41)
REFRESH_TIMER_RESET is placed at feedback node 644 (MC 44)
REFRESH_GRANT is placed at pin 31 (MC 46)
CAS_PRE is placed at feedback node 647 (MC 47)
FB_170 is placed at foldback expander node 347 (MC 47)
TCK is placed at pin 32 (MC 48)
REFRESH_REQUESTED is placed at feedback node 648 (MC 48)
FB_169 is placed at foldback expander node 348 (MC 48)
CPU1_RW is placed at pin 33 (MC 49)
TDO is placed at pin 38 (MC 56)

                                                                 
                                                                 
                                                                 
                                 S                               
                                 Y                               
                              C  S                               
                              L  _                               
                              K  R                               
                  C  C  C     _  E                               
                  A  A  A  V  3  S       G                       
                  S  S  S  C  2  E       N                       
                  2  1  0  C  M  T       D                       
               ____________________________________              
              /   6  5  4  3  2  1 44 43 42 41 40  \             
         TDI |  7                                39 |            
        CAS3 |  8                                38 | TDO        
        RAS0 |  9                                37 |            
         GND | 10                                36 |            
        RAS1 | 11                                35 | VCC        
       AREQ0 | 12            ATF1504             34 |            
         TMS | 13          44-Lead PLCC          33 | CPU1_RW    
       AREQ1 | 14                                32 | TCK        
         VCC | 15                                31 | REFRESH_GRANT
      GRANT0 | 16                                30 | GND        
      GRANT1 | 17                                29 | CPU0_LDS   
             |   18 19 20 21 22 23 24 25 26 27 28   |            
              \____________________________________/             
                 C  C  D  D  G  V  C  C  C  C  C                 
                 P  P  R  R  N  C  L  P  P  P  P                 
                 U  U  A  A  D  C  K  U  U  U  U                 
                 0  1  M  M        _  0  1  0  0                 
                 _  _  _  _        1  _  _  _  _                 
                 D  D  A  R        6  A  A  U  R                 
                 R  R  B  W        M  1  1  D  W                 
                 A  A              _        S                    
                 M  M              I                             
                 _  _              N                             
                 D  D              T                             
                 T  T              E                             


*/


/* SIMULATOR LOGIC */
/*
Pin[33,34,36] = SIM_AS, SIM_DRAM_CS, SIM_RW;
Pin[31] = SIM_DTACK_IN;
Pin[37] = SIM_START_BUTTON;
*/
// These next two pins must be connected together.  They add a 7ns delay to the AS signal so it replicates
// what happens in a 68K system at 16Mhz.
/*
Pin[44] = SIM_AS_IN;     
Pin[41] = SIM_AS_OUT;
NODE [SIM_S0..7];
NODE SIM_START_LATCH;

SIM_START_LATCH.d = SIM_START_BUTTON;
SIM_START_LATCH.ck = !SIM_START_BUTTON;
SIM_START_LATCH.ap = !SYS_RESET;


SIM_S0.ck = CLK_16M_INTERNAL;
SIM_S2.ck = CLK_16M_INTERNAL;
SIM_S4.ck = CLK_16M_INTERNAL;
SIM_S6.ck = CLK_16M_INTERNAL;
SIM_S1.ck = !CLK_16M_INTERNAL;
SIM_S3.ck = !CLK_16M_INTERNAL;
SIM_S5.ck = !CLK_16M_INTERNAL;
SIM_S7.ck = !CLK_16M_INTERNAL;


SIM_S0.ap = !SYS_RESET # !SIM_S7;
SIM_S1.ap = !SYS_RESET # !SIM_S7;
SIM_S2.ap = !SYS_RESET # !SIM_S7;
SIM_S3.ap = !SYS_RESET # !SIM_S7;
SIM_S4.ap = !SYS_RESET # !SIM_S7;
SIM_S5.ap = !SYS_RESET # !SIM_S7;
SIM_S6.ap = !SYS_RESET # !SIM_S7;
SIM_S7.ap = !SYS_RESET # SIM_S0;

SIM_S0.d = SIM_START_LATCH;
SIM_S1.d = SIM_S0;
SIM_S2.d = SIM_S1;
SIM_S3.d = SIM_S2;
SIM_S4.d = SIM_S3;
SIM_S5.d = SIM_S4 # SIM_DTACK_IN;
SIM_S6.d = SIM_S5;
SIM_S7.d = SIM_S6;

NODE SIM_AS_PRE;

SIM_AS_OUT = SIM_AS # !SYS_RESET;
SIM_AS = SIM_S2 # !SIM_S7;
SIM_DRAM_CS = SIM_AS_IN # SIM_S1 # SIM_S0 # !SYS_RESET;    
*/

/* END OF SIMULATOR LOGIC */

