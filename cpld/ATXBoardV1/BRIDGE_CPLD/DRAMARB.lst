LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

  1:Name       DRAMARB;
  2:PartNo   DRAMARB;
  3:Date     05/28/2023;
  4:Revision 01;
  5:Designer Sponaugle;
  6:Company  Ratiometric;
  7:Assembly None;
  8:Location None;
  9:Device   f1504ispplcc44;
 10:
 11:
 12:/* 
 13:   Version 1.1 - 3 node, with 1 node always at high priority.  Use case is for DRAM Refresh, since that should
 14:*/
 15:
 16:PROPERTY ATMEL {TDI_PULLUP = ON};
 17:PROPERTY ATMEL {TMS_PULLUP = ON};
 18:
 19:/** Pins that will be exposed in the final design  **/
 20:
 21:// INPUTS

 22:Pin[2]     = CLK_32M;                  /* Clock */
 23:Pin[1]     = SYS_RESET;                /* Active Low Reset */
 24:Pin[12,14] = [AREQ0..1];                  /* Active Low Request, clocked internaly on CLK+ edge */
 25:Pin[25,26] = CPU0_A1, CPU1_A1;
 26:Pin[27,28] = CPU0_UDS, CPU1_UDS;
 27:Pin[29,31] = CPU0_LDS, CPU1_LDS;
 28:Pin[28]    = CPU0_RW;
 29:Pin[33]    = CPU1_RW;
 30:
 31:// OUTPUTS

 32:Pin[9,11]    = [RAS0..1];
 33:Pin[4,5,6,8] = [CAS0..3];
 34:Pin[21,20]   = DRAM_RW, DRAM_AB;
 35:Pin[18,19]   = CPU0_DRAM_DTACK, CPU1_DRAM_DTACK;
 36:
 37:Pin[16,17]   = [GRANT0..1];                /* Active Low Grant, clocked output on CLK- edge */
 38:
 39:/* Pins that are being exposed to enable debugging */
 40:Pin[31] = REFRESH_GRANT;
 41:Pin[24] = CLK_16M_INTERNAL;
 42:
 43:Pin[34] = UNUSED_IO0;
 44:Pin[36] = UNUSED_IO1;
 45:Pin[37] = UNUSED_IO2;
 46:Pin[39] = UNUSED_IO3;
 47:Pin[40] = UNUSED_IO4;
 48:Pin[41] = UNUSED_IO5;
 49:Pin[43] = UNUSED_IONLY0;
 50:Pin[44] = UNUSED_IONLY1;
 51:
 52:NODE [REQ_CLOCKED0..1];
 53:NODE PE_BIAS;

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

 54:NODE REFRESH_TIMER_RESET;
 55:NODE [REFRESH_TIMER0..7];
 56://NODE CLK_16M_INTERNAL;

 57:NODE REFRESH_REQUESTED, REFRESH_COMPLETED, REFRESH_REQ_CLOCKED;
 58:NODE CAS_PRE;
 59:NODE REFRESH_COMPLETED_PRE0, REFRESH_COMPLETED_PRE1, REFRESH_COMPLETED_PRE2;
 60:/* Internally generated 16Mhz clock used for the refresh timer */
 61:
 62:CLK_16M_INTERNAL.d = !CLK_16M_INTERNAL;
 63:CLK_16M_INTERNAL.ck = CLK_32M;
 64:CLK_16M_INTERNAL.ar = !SYS_RESET;
 65:
 66:/* 
 67:    Clocking the incoming access request for each CPU, as well as the request from the REFRESH generator.
 68:    All three of these are clocked on the falling of CLK32M.   These go into the priority encoder and the 
 69:    output of the priority encoder (the GRANT signals) are clocked on the rising edge of CLK32M.
 70: */
 71:REQ_CLOCKED0.d = AREQ0;
 72:REQ_CLOCKED1.d = AREQ1;
 73:[REQ_CLOCKED0..1].ck = !CLK_32M;
 74:[REQ_CLOCKED0..1].ap = !SYS_RESET;
 75:
 76:REFRESH_REQ_CLOCKED.ck = !CLK_32M;
 77:REFRESH_REQ_CLOCKED.d = REFRESH_REQUESTED;
 78:REFRESH_REQ_CLOCKED.ap = !SYS_RESET;
 79:
 80:
 81:/* 
 82:    The priority encoder takes the clocked request above and picks a winner.  If the REFRESH request is active it always wins,
 83:    but between the two CPU request the winner is alternted by a 'BIAS' flag.  That BIAS flag alternates between 0 and 1, with
 84:    that BIAS applied to pick the winner.  The BIAS flag changes with the falling edge of a signal called 'GRANT_ACTIVE', 
 85:    and that signal is a combination all of the GRANT flags, thus is set to 0 whenever any access grant happens. 
 86:*/
 87://

 88:PE_BIAS.d = !PE_BIAS;
 89:PE_BIAS.ck = !GRANT_ACTIVE;        /* Flip the PE_BIAS each time we start a new grant cycle */
 90:PE_BIAS.ar = !SYS_RESET;
 91:
 92:GRANT_ACTIVE = GRANT0 & GRANT1 & REFRESH_GRANT;   /* Active low signal that there is a active grant of access from 1 of 3 sources */
 93:
 94:PE_REFRESH_OUT = REFRESH_REQ_CLOCKED;            /* refresh requests always win */
 95:PE_OUT_0 = ( REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # PE_BIAS ) & 
 96:           ( REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # !REQ_CLOCKED1 # !PE_BIAS );                             /* if BIAS is towards input 0, set output0 if input0 is set */
 97:                                /* if BIAS is towards input 1, set output0 if input0 is set AND input 1 is not */
 98:PE_OUT_1 = ( REQ_CLOCKED1 # !REQ_CLOCKED0 # !REFRESH_REQ_CLOCKED # PE_BIAS ) &
 99:           ( REQ_CLOCKED1 # !REFRESH_REQ_CLOCKED # !PE_BIAS ) ;   /* if BIAS is towards input 0, set output1 if input1 is set AND input 0 is not */
100:          
101:         
102:REFRESH_GRANT.d = ( !GRANT_ACTIVE & REFRESH_GRANT ) #          /* If a grant is active, don't change output state */
103:                  ( GRANT_ACTIVE & PE_REFRESH_OUT );           /* If a grant is not active, grab the output from the priority encoder */
104:REFRESH_GRANT.ap = REFRESH_REQUESTED # !REFRESH_COMPLETED # !SYS_RESET;
105:REFRESH_GRANT.ck = CLK_32M;
106:
107://GRANT0.d = ( !GRANT_ACTIVE & GRANT0 ) #        /* If a grant is active, don't change output state */


LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

108://          ( GRANT_ACTIVE & PE_OUT_0 );         /* If a grant is not active, grab the output from the priority encoder */

109:
110:
111:GRANT0.D =  ( !GRANT_ACTIVE & GRANT0 ) #  
112:            ( GRANT_ACTIVE & PE_OUT_0 );
113:GRANT0.AP = AREQ0 # !SYS_RESET;
114:GRANT0.CK = CLK_32M;
115:
116:GRANT1.d =  ( !GRANT_ACTIVE & GRANT1 ) #  
117:            ( GRANT_ACTIVE & PE_OUT_1 );         /* If a grant is not active, grab the output from the priority encoder */       
118:GRANT1.ap = AREQ1 # !SYS_RESET;
119:GRANT1.ck = CLK_32M;
120:
121:CPU0_DRAM_DTACK = GRANT0;
122:CPU1_DRAM_DTACK = GRANT1;
123:
124:/* 
125:   REFRESH REQUESTED is a latch that is set to 0 when a refresh is needed, and cleared back to 1 once the refresh has
126:   occured.   REFRESH_COMPLETED should be set to 1 when the refresh is completed.
127:*/
128:
129:REFRESH_REQUESTED.d = 'b'0;  // disabled REFRESH  THIS SHOULD BE 0 TO ENABLE REFRESH TO HAPPEN.

130:REFRESH_REQUESTED.ck = REFRESH_TIMER7;
131:REFRESH_REQUESTED.ap = !REFRESH_COMPLETED # !SYS_RESET;
132:
133:/* 
134:   REFRESH_COMPLETED is a tree of gates that create a delay from the start to the end of the refresh cycle.
135:
136:*/
137:
138:REFRESH_COMPLETED_PRE0.d = REFRESH_GRANT;
139:REFRESH_COMPLETED_PRE0.ck = !CLK_32M;
140:REFRESH_COMPLETED_PRE0.ap = REFRESH_REQUESTED # !SYS_RESET;
141:
142:REFRESH_COMPLETED_PRE1.d = REFRESH_COMPLETED_PRE0;
143:REFRESH_COMPLETED_PRE1.ck = !CLK_32M;
144:REFRESH_COMPLETED_PRE1.ap = REFRESH_REQUESTED # !SYS_RESET;
145:
146:REFRESH_COMPLETED_PRE2.d = REFRESH_COMPLETED_PRE1;
147:REFRESH_COMPLETED_PRE2.ck = !CLK_32M;
148:REFRESH_COMPLETED_PRE2.ap = REFRESH_REQUESTED # !SYS_RESET;
149:
150:REFRESH_COMPLETED.d = REFRESH_COMPLETED_PRE2;
151:REFRESH_COMPLETED.ck = !CLK_32M;
152:REFRESH_COMPLETED.ap = REFRESH_REQUESTED # !SYS_RESET;
153:
154:
155:/* RAS, CAS, RW, and AB for DRAM access */
156:// MEMORY_ACCESS_ACTIVE is zero if there is an active memory DRAM access cycle in progress.

157:
158:MEMORY_ACCESS_GRANT_ACTIVE = (GRANT0 & GRANT1);
159:REFRESH_ACCESS_GRANT_ACTIVE = REFRESH_GRANT;
160:
161:[RAS0..1].ck = !CLK_32M;

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

162:[RAS0..1].ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET;     // If the memory access granted ends, reset the RAS lines

163:RAS0.d = ( GRANT0 # CPU0_A1 ) & ( GRANT1 # CPU1_A1) & ( REFRESH_GRANT # CAS0 );
164:RAS1.d = ( GRANT0 # !CPU0_A1 ) & ( GRANT1 # !CPU1_A1)  & ( REFRESH_GRANT # CAS0 );
165:
166:CAS_PRE.d = MEMORY_ACCESS_GRANT_ACTIVE;
167:CAS_PRE.ck = !CLK_32M;
168:CAS_PRE.ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 
169:
170:[CAS0..3].ck = !CLK_32M;
171:[CAS0..3].ap = ((!GRANT0) & AREQ0) # ((!GRANT1) & AREQ1) # ((!REFRESH_GRANT) & !REFRESH_COMPLETED) # !SYS_RESET; 
172:
173:CAS0.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
174:CAS1.d = (( CAS_PRE # GRANT0 # CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
175:CAS2.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_LDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_LDS) & (REFRESH_GRANT ));
176:CAS3.d = (( CAS_PRE # GRANT0 # !CPU0_A1 # CPU0_UDS ) & ( CAS_PRE # GRANT1 # !CPU1_A1 # CPU0_UDS) & (REFRESH_GRANT ));
177:
178:/* The DRAM R/W signal will mirror the CPU_RW signal if we are doing a memory access.  If we are doing a refresh 
179:   cycle, it will be fixed at 1 */
180:
181:DRAM_RW = (!GRANT0 & CPU0_RW) # (!GRANT1 & CPU1_RW) # MEMORY_ACCESS_GRANT_ACTIVE; 
182:
183:/* 
184:   DRAM AB selects either the row address or the col address going to the memory.  1=ROW, 1=COL.  It is 1 at reset and held at one if
185:   MEMORY_ACCESS_GRANT_ACTIVE is 1.  As soon as a memory access cycle starts, it is unlocked and will toggle to 0 once one of the two RAS 
186:   signals goes to zero.  That puts the AB signal about 7ns behind the RAS signal, and the actual 2:1 mux delay will add another 10-12ns of
187:   delay.  That is just enough to get the COL address to the memory before the CAS signals goes to zero.
188:*/
189:DRAM_AB.d = 'b'0;
190:DRAM_AB.ck = !RAS0 # !RAS1;
191:DRAM_AB.ap = MEMORY_ACCESS_GRANT_ACTIVE # !SYS_RESET;
192:
193:
194:
195:/* REFRESH TIMER for generating REFRESH REQUESTS */
196:
197:/* 
198:   8 bit counter for refresh time.  This is built with 2x 4 bit counters that are chained 
199:   together.  In order to get a 15us cycle, this counter is preset to 0x08 on 'reset', and counts
200:   up to 128.  At 128 the REFRESH_REQUESTED event is triggered and the counter is 'reset' back to
201:   0x08.  The produces an event every 15us with an 8MHz clock.   
202:
203:   If the clock rate is not 32MHz for the core input, this will need to be adjusted.
204:
205:   The REFESH_TMER_RESET flip flop is used to produce a 1 clock cycle long reset signal once the 
206:   counter reaches 128 (highest bit set).  The output of that flipflop resets the counter value to 
207:   0x08.
208:*/
209:
210:REFRESH_TIMER_RESET.d = REFRESH_TIMER7;
211:REFRESH_TIMER_RESET.ck = CLK_32M;
212:REFRESH_TIMER_RESET.ar = !SYS_RESET;
213:
214:REFRESH_TIMER0.d = !REFRESH_TIMER0;
215:REFRESH_TIMER1.d = REFRESH_TIMER0 $ REFRESH_TIMER1;

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

216:REFRESH_TIMER2.d = ( REFRESH_TIMER2 & !REFRESH_TIMER0 )
217:                    # ( REFRESH_TIMER2 & !REFRESH_TIMER1 )
218:                    # ( !REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );
219:REFRESH_TIMER3.d = ( REFRESH_TIMER3 & !REFRESH_TIMER2 )
220:                    # ( REFRESH_TIMER3 & !REFRESH_TIMER0 )
221:                    # ( REFRESH_TIMER3 & !REFRESH_TIMER1 )
222:                    # ( !REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0 );
223:
224:REFRESH_TIMER4.d = !REFRESH_TIMER4;
225:REFRESH_TIMER5.d = REFRESH_TIMER4 $ REFRESH_TIMER5;
226:REFRESH_TIMER6.d = ( REFRESH_TIMER6 & !REFRESH_TIMER4 )
227:                    # ( REFRESH_TIMER6 & !REFRESH_TIMER5 )
228:                    # ( !REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );
229:REFRESH_TIMER7.d = ( REFRESH_TIMER7 & !REFRESH_TIMER6 )
230:                    # ( REFRESH_TIMER7 & !REFRESH_TIMER4 )
231:                    # ( REFRESH_TIMER7 & !REFRESH_TIMER5 )
232:                    # ( !REFRESH_TIMER7 & REFRESH_TIMER6 & REFRESH_TIMER5 & REFRESH_TIMER4 );
233:
234:
235:/* This should normally be CLK_8M, but on the proto board we are starting with a 16MHz OSC and an
236:8MHz CPU Clock, this CLK_16M is actually Mhz */
237:/*[REFRESH_TIMER0..3].ck = CLK_8M;*/
238:
239:[REFRESH_TIMER0..3].ck = CLK_16M_INTERNAL;
240:[REFRESH_TIMER4..7].ck = !(REFRESH_TIMER3 & REFRESH_TIMER2 & REFRESH_TIMER1 & REFRESH_TIMER0);
241:
242:/*      
243:        At reset we want to set all bits to 0 except bit 3, which is the same as loading 0x08 into the counter.
244:        From 0x08 to 0x80 will give is the correct time period of 15us.
245:*/
246:
247:[REFRESH_TIMER0..2].ar = REFRESH_TIMER_RESET # !SYS_RESET;
248:[REFRESH_TIMER4..7].ar = REFRESH_TIMER_RESET # !SYS_RESET;
249:REFRESH_TIMER3.ap = REFRESH_TIMER_RESET # !SYS_RESET;
250:
251:
252:
253:
254:/*
255:
256:Total dedicated input used:     2/4     (50%)
257:Total I/O pins used             26/32   (81%)
258:Total Logic cells used          37/64   (57%)
259:Total Flip-Flop used            30/64   (46%)
260:Total Foldback logic used       12/64   (18%)
261:Total Nodes+FB/MCells           47/64   (73%)
262:Total cascade used              2
263:Total input pins                14
264:Total output pins               14
265:Total Pts                       123
266:
267:
268:Final global control pins assignment (if applicable)...
269:-------------------------------------------------------

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 6

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

270:CLK_32M assigned to pin  2
271:SYS_RESET assigned to pin  1
272:
273:
274:
275:Performing input pin pre-assignments ...
276:------------------------------------
277:CLK_32M assigned to pin  2
278:SYS_RESET assigned to pin  1
279:DRAM_AB.AP equation needs patching.
280:1 control eqution need patching
281:
282:Attempt to place floating signals ...
283:------------------------------------
284:AREQ0 is placed at pin 12 (MC 1)
285:REFRESH_COMPLETED_PRE0 is placed at feedback node 601 (MC 1)
286:PE_BIAS is placed at feedback node 602 (MC 2)
287:RAS1 is placed at pin 11 (MC 3)
288:RAS0 is placed at pin 9 (MC 4)
289:CAS3 is placed at pin 8 (MC 5)
290:REFRESH_TIMER4 is placed at feedback node 606 (MC 6)
291:REFRESH_TIMER5 is placed at feedback node 607 (MC 7)
292:TDI is placed at pin 7 (MC 8)
293:REFRESH_TIMER2 is placed at feedback node 608 (MC 8)
294:REFRESH_TIMER7 is placed at feedback node 610 (MC 10)
295:CAS2 is placed at pin 6 (MC 11)
296:FB_171 is placed at foldback expander node 311 (MC 11)
297:FB_168 is placed at foldback expander node 312 (MC 12)
298:REFRESH_TIMER3 is placed at feedback node 613 (MC 13)
299:Com_Ctrl_166 is placed at foldback expander node 313 (MC 13)
300:CAS1 is placed at pin 5 (MC 14)
301:Com_Ctrl_165 is placed at foldback expander node 314 (MC 14)
302:REFRESH_TIMER6 is placed at feedback node 615 (MC 15)
303:CAS0 is placed at pin 4 (MC 16)
304:Com_Ctrl_164 is placed at foldback expander node 316 (MC 16)
305:DRAM_RW is placed at pin 21 (MC 17)
306:REQ_CLOCKED0 is placed at feedback node 618 (MC 18)
307:DRAM_AB is placed at pin 20 (MC 19)
308:CPU1_DRAM_DTACK is placed at pin 19 (MC 20)
309:CPU0_DRAM_DTACK is placed at pin 18 (MC 21)
310:REQ_CLOCKED1 is placed at feedback node 622 (MC 22)
311:REFRESH_REQ_CLOCKED is placed at feedback node 623 (MC 23)
312:GRANT1 is placed at pin 17 (MC 24)
313:GRANT0 is placed at pin 16 (MC 25)
314:DRAM_AB.AP is placed at feedback node 626 (MC 26)
315:REFRESH_COMPLETED_PRE1 is placed at feedback node 627 (MC 27)
316:REFRESH_COMPLETED_PRE2 is placed at feedback node 628 (MC 28)
317:FB_174 is placed at foldback expander node 328 (MC 28)
318:REFRESH_COMPLETED is placed at feedback node 629 (MC 29)
319:FB_173 is placed at foldback expander node 329 (MC 29)
320:AREQ1 is placed at pin 14 (MC 30)
321:REFRESH_TIMER0 is placed at feedback node 630 (MC 30)
322:FB_172 is placed at foldback expander node 330 (MC 30)
323:Com_Ctrl_167 is placed at feedback node 631 (MC 31)

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 7

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

324:Com_Ctrl_166 is placed at foldback expander node 331 (MC 31)
325:TMS is placed at pin 13 (MC 32)
326:REFRESH_TIMER1 is placed at feedback node 632 (MC 32)
327:Com_Ctrl_165 is placed at foldback expander node 332 (MC 32)
328:CLK_16M_INTERNAL is placed at pin 24 (MC 33)
329:CPU0_A1 is placed at pin 25 (MC 35)
330:CPU1_A1 is placed at pin 26 (MC 36)
331:CPU0_UDS is placed at pin 27 (MC 37)
332:CPU0_RW is placed at pin 28 (MC 40)
333:CPU0_LDS is placed at pin 29 (MC 41)
334:REFRESH_TIMER_RESET is placed at feedback node 644 (MC 44)
335:REFRESH_GRANT is placed at pin 31 (MC 46)
336:CAS_PRE is placed at feedback node 647 (MC 47)
337:FB_170 is placed at foldback expander node 347 (MC 47)
338:TCK is placed at pin 32 (MC 48)
339:REFRESH_REQUESTED is placed at feedback node 648 (MC 48)
340:FB_169 is placed at foldback expander node 348 (MC 48)
341:CPU1_RW is placed at pin 33 (MC 49)
342:TDO is placed at pin 38 (MC 56)
343:
344:                                                                 
345:                                                                 
346:                                                                 
347:                                 S                               
348:                                 Y                               
349:                              C  S                               
350:                              L  _                               
351:                              K  R                               
352:                  C  C  C     _  E                               
353:                  A  A  A  V  3  S       G                       
354:                  S  S  S  C  2  E       N                       
355:                  2  1  0  C  M  T       D                       
356:               ____________________________________              
357:              /   6  5  4  3  2  1 44 43 42 41 40  \             
358:         TDI |  7                                39 |            
359:        CAS3 |  8                                38 | TDO        
360:        RAS0 |  9                                37 |            
361:         GND | 10                                36 |            
362:        RAS1 | 11                                35 | VCC        
363:       AREQ0 | 12            ATF1504             34 |            
364:         TMS | 13          44-Lead PLCC          33 | CPU1_RW    
365:       AREQ1 | 14                                32 | TCK        
366:         VCC | 15                                31 | REFRESH_GRANT
367:      GRANT0 | 16                                30 | GND        
368:      GRANT1 | 17                                29 | CPU0_LDS   
369:             |   18 19 20 21 22 23 24 25 26 27 28   |            
370:              \____________________________________/             
371:                 C  C  D  D  G  V  C  C  C  C  C                 
372:                 P  P  R  R  N  C  L  P  P  P  P                 
373:                 U  U  A  A  D  C  K  U  U  U  U                 
374:                 0  1  M  M        _  0  1  0  0                 
375:                 _  _  _  _        1  _  _  _  _                 
376:                 D  D  A  R        6  A  A  U  R                 
377:                 R  R  B  W        M  1  1  D  W                 

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 8

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

378:                 A  A              _        S                    
379:                 M  M              I                             
380:                 _  _              N                             
381:                 D  D              T                             
382:                 T  T              E                             
383:
384:
385:
386:*/
387:
388:
389:/* SIMULATOR LOGIC */
390:/*
391:Pin[33,34,36] = SIM_AS, SIM_DRAM_CS, SIM_RW;
392:Pin[31] = SIM_DTACK_IN;
393:Pin[37] = SIM_START_BUTTON;
394:*/
395:// These next two pins must be connected together.  They add a 7ns delay to the AS signal so it replicates

396:// what happens in a 68K system at 16Mhz.

397:/*
398:Pin[44] = SIM_AS_IN;     
399:Pin[41] = SIM_AS_OUT;
400:NODE [SIM_S0..7];
401:NODE SIM_START_LATCH;
402:
403:SIM_START_LATCH.d = SIM_START_BUTTON;
404:SIM_START_LATCH.ck = !SIM_START_BUTTON;
405:SIM_START_LATCH.ap = !SYS_RESET;
406:
407:
408:SIM_S0.ck = CLK_16M_INTERNAL;
409:SIM_S2.ck = CLK_16M_INTERNAL;
410:SIM_S4.ck = CLK_16M_INTERNAL;
411:SIM_S6.ck = CLK_16M_INTERNAL;
412:SIM_S1.ck = !CLK_16M_INTERNAL;
413:SIM_S3.ck = !CLK_16M_INTERNAL;
414:SIM_S5.ck = !CLK_16M_INTERNAL;
415:SIM_S7.ck = !CLK_16M_INTERNAL;
416:
417:
418:SIM_S0.ap = !SYS_RESET # !SIM_S7;
419:SIM_S1.ap = !SYS_RESET # !SIM_S7;
420:SIM_S2.ap = !SYS_RESET # !SIM_S7;
421:SIM_S3.ap = !SYS_RESET # !SIM_S7;
422:SIM_S4.ap = !SYS_RESET # !SIM_S7;
423:SIM_S5.ap = !SYS_RESET # !SIM_S7;
424:SIM_S6.ap = !SYS_RESET # !SIM_S7;
425:SIM_S7.ap = !SYS_RESET # SIM_S0;
426:
427:SIM_S0.d = SIM_START_LATCH;
428:SIM_S1.d = SIM_S0;
429:SIM_S2.d = SIM_S1;
430:SIM_S3.d = SIM_S2;
431:SIM_S4.d = SIM_S3;

LISTING FOR LOGIC DESCRIPTION FILE: DRAMARB.pld                      Page 9

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Sat Jun 24 09:21:49 2023

432:SIM_S5.d = SIM_S4 # SIM_DTACK_IN;
433:SIM_S6.d = SIM_S5;
434:SIM_S7.d = SIM_S6;
435:
436:NODE SIM_AS_PRE;
437:
438:SIM_AS_OUT = SIM_AS # !SYS_RESET;
439:SIM_AS = SIM_S2 # !SIM_S7;
440:SIM_DRAM_CS = SIM_AS_IN # SIM_S1 # SIM_S0 # !SYS_RESET;    
441:*/
442:
443:/* END OF SIMULATOR LOGIC */
444:
445:
446:



