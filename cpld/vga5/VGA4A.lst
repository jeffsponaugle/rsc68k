LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

  1:Name     VGA4A;
  2:PartNo   VGA4A;
  3:Date     05/10/2022;
  4:Revision 01;
  5:Designer Sponaugle;
  6:Company  Ratiometric;
  7:Assembly None;
  8:Location None;
  9:Device   f1508ispplcc84;
 10:
 11:
 12:/* 
 13:   Version 1.12a
 14:       Compressed and spread into 2 CPLDS.
 15:   
 16:*/
 17:
 18:/*
 19:
 20:    VRAM_AD_OE  Enable Address and Dataline buffers from CPU to video memory.
 21:
 22:    VGA_CPU_ACCESS_ALLOWED - (hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
 23:    VGA_BUSY - FF clocked to RAM_OE by EXP_CS_C, Cleared to 1 by VGA_BUSY==1.   
 24:    
 25:*/
 26:
 27:/*  
 28:               MHz         Horizontal (in Pixels)                                  Vertical (in Lines)
 29:Format  Pixel Clock    Active Video   Front_Porch Sync_Pulse  Back_Porch        Active_Video    Front_Porch     Sync_Pulse Back_Porch
 30:640x480, 60Hz   25.175  640              16              -96          48                 480             11             -2               31
 31:640x480, 72Hz   31.500  640              24              -40          128             480                9              -3               2
 32:
 33:*/
 34:
 35:
 36:PROPERTY ATMEL {TDI_PULLUP = ON};
 37:PROPERTY ATMEL {TMS_PULLUP = ON};
 38:
 39:/** Inputs **/
 40:
 41:Pin[83] = CLK_25M;                  /* 25.175Mhz input clock  - Master Pixel Clock */
 42:Pin[1]  = VGA_RESET;                /* Active Low Reset */
 43:Pin[10]  = CPU_VGA_VRAM_CS;         /* Chip Select from CPU to access video memory */
 44:Pin[11] = CPU_VGA_CFG_CS;           /* Chip Select from CPU to access VGA Configuration register */
 45:Pin[12] = CPU_UDS;                  /* CPU Upper Byte Select */
 46:Pin[15] = CPU_LDS;                  /* CPU Lower Byte Select */
 47:Pin[16] = CPU_RW;                   /* CPU signal for reading or writing */
 48:Pin[17,18,20,21,22,24,25,27] = [SREG_IN0..7];      /* Data bus input for shift register.  Connect to Char ROM */
 49:
 50:/** Outputs **/
 51:
 52:Pin[4] = VGA_HSYNC;                 /* Horizonal Sync Output */
 53:Pin[5] = VGA_VSYNC;                 /* Vertical Sync Output */

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

 54:Pin[6] = VGA_VIDEO_ENABLE;          /* Enable Color Video Signal Output to Connector */
 55:Pin[29] = VRAM_LOW_CE;              /* Chip Enable for Vido RAM Low Output */
 56:Pin[30] = VRAM_HIGH_CE;             /* Chip Enable for Video RAM High Output */
 57:Pin[31] = VRAM_OE;                  /* Output Enable for both Video RAMs  */
 58:Pin[33] = VRAM_WE;                  /* Write Enable for both Video RAMs */
 59:Pin[48,46] = GRAPH_MODE0,GRAPH_MODE1;       /* 00 = TEXT, 01=GRAPHICS, 10,11 Unused */
 60:
 61:/* 
 62:   Video Ram data bus input, RGB output, and internal lataches for data bus input.
 63:*/
 64:
 65:Pin [74,73,70,69,68,67,65,64,63,61,60,58,57,56,55,54]= [VMEM_SRCD0..15];      /* Databus from Video Memory */
 66:Pin [81,80]= [VRED_OUT0..1];        /* Red Color output bits */                  
 67:Pin [79,77]= [VGREEN_OUT0..1];      /* Green Color output bits */     
 68:Pin [76,75]= [VBLUE_OUT0..1];       /* Blue Color output bits */     
 69:
 70:/* Address lines that go to the character rom for text mode.  */
 71:Pin[40,39,37,36] = [FRAM_A0..3];      /* Selects the row for a given font (16 rows per char) */   
 72:
 73:/* Signals back to the host CPU */
 74:Pin[9] = CPU_VRAM_DTACK;            /* Signal back to CPU to hold VRAM access cycle while video gen */
 75:Pin[8] = VERT_SYNC_INTERRUPT;       /* Interrupt signal to CPU for start of vert refresh */
 76:
 77:/* control line for CPU to Video RAM interface */
 78:Pin[41] = SBUS_TO_VRAM_AD_OE;       /* Output Enable for CPU <-> Video RAM Address and Data Bus */
 79:Pin[44] = VGA_CONFIG_WRITE;         /* Enable to second CPLD for config register write */
 80:Pin[52,51,50] = [VADDR_MODE0..2];   /* second CPLD VRAM address increment mode */
 81:
 82:/* Pins to second CPLD 
 83:    VGA_CONFIG_WRITE: Signal that the CPU is writing to the config register inside the address CPLD.
 84:
 85:    VADDR_MODE: 3 bit signal to tell the address generation CPLD what to do on the next clock cycle.
 86:
 87:     [VADDR_MODE0..2] - Address Increment Mode
 88:        000  DO NOTHING   vaddr_mode_field:['d'0] 
 89:        001  INCREMENT    vaddr_mode_field:['d'1] Increment Address by 1
 90:        010  RESET_A6     vaddr_mode_field:['d'2] Reset Lower 6 bits of Address - For Text Mode to repeat a line (for char font)
 91:        011  RESET_A6I    vaddr_mode_field:['d'3] Reset Lower 6 bits of Address, and increment remaining upper bits by 1.  (NEXT LINE)
 92:        100  RESET_ALL    vaddr_mode_field:['d'4] Reset All Address Bits back to TOP
 93:        101  RESET_ALL    vaddr_mode_field:['d'5] Reset All Address Bits back to TOP
 94:        110  RESET_ALL    vaddr_mode_field:['d'6] Reset All Address Bits back to TOP
 95:        111  RESET_ALL    vaddr_mode_field:['d'7] Reset All Address Bits back to TOP
 96:                          vaddr_mode_field:['d'4..'d'7]
 97:*/
 98:
 99:NODE [VMEM_SRC_LATCHED0..15];
100:NODE [HSYNC_COUNTER0..9];
101:NODE [VSYNC_COUNTER0..9];
102:NODE VSYNC_CLOCK_A,VSYNC_CLOCK_B;
103:NODE SREG_LOAD,SREG_SHIFT;
104:NODE VGA_BUSY,VGA_BUSY_CSLOCKED, CPU_VRAM_CS_CLOCKED , CPU_VRAM_ACCESS_ENABLED;
105:NODE RAM_OE;
106:NODE [SREG_D0..7];
107:

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

108:/*  ________________________________________________________________ */
109:/* Shift Register Implementation 
110:    SREG_Dx are the storage registers.  D7 is the output.
111:    SREG_LOAD is an active high signal to load from SREG_IN the 8 bit value
112:    SREG_SHIFT is an active high signal to shift from 0-->7 on clock.   
113:    SREG_LOAD overrides SREG_SHIFT.
114:    if neither SREG_LOAD or SREG_SHIFT are high the register value stays the same.
115:*/
116:
117:SREG_D0.d = (SREG_LOAD & SREG_IN0) # (!SREG_LOAD & !SREG_SHIFT & SREG_D0);
118:SREG_D1.d = (SREG_LOAD & SREG_IN1) # (!SREG_LOAD & SREG_SHIFT & SREG_D0) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D1 );
119:SREG_D2.d = (SREG_LOAD & SREG_IN2) # (!SREG_LOAD & SREG_SHIFT & SREG_D1) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D2 );
120:SREG_D3.d = (SREG_LOAD & SREG_IN3) # (!SREG_LOAD & SREG_SHIFT & SREG_D2) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D3 );
121:SREG_D4.d = (SREG_LOAD & SREG_IN4) # (!SREG_LOAD & SREG_SHIFT & SREG_D3) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D4 );
122:SREG_D5.d = (SREG_LOAD & SREG_IN5) # (!SREG_LOAD & SREG_SHIFT & SREG_D4) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D5 );
123:SREG_D6.d = (SREG_LOAD & SREG_IN6) # (!SREG_LOAD & SREG_SHIFT & SREG_D5) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D6 );
124:SREG_D7.d = (SREG_LOAD & SREG_IN7) # (!SREG_LOAD & SREG_SHIFT & SREG_D6) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D7 );
125:
126:SREG_D0.ck = CLK_25M;
127:SREG_D1.ck = CLK_25M;
128:SREG_D2.ck = CLK_25M;
129:SREG_D3.ck = CLK_25M;
130:SREG_D4.ck = CLK_25M;
131:SREG_D5.ck = CLK_25M;
132:SREG_D6.ck = CLK_25M;
133:SREG_D7.ck = CLK_25M;
134:
135:SREG_D0.ar = !VGA_RESET;
136:SREG_D1.ar = !VGA_RESET;
137:SREG_D2.ar = !VGA_RESET;
138:SREG_D3.ar = !VGA_RESET;
139:SREG_D4.ar = !VGA_RESET;
140:SREG_D5.ar = !VGA_RESET;
141:SREG_D6.ar = !VGA_RESET;
142:SREG_D7.ar = !VGA_RESET;
143:
144:
145:/*  ________________________________________________________________ */
146:
147:
148:/* 
149:    Video Out MUX:  In Text mode, pass thru the RGB _IN to _OUT if SREG_D7==1 and we are in the active region.
150:                    In Graphics mode, pass thru RGB _IN to +_OUT all of the time if we are in the active region. 
151:                    Active Region is RAM_OE.
152:    SRC Latch activated by CLK_25 as well as SR_LOAD.  SR_LOAD is used to both latch this data as well
153:    as latch data into the shift register.
154:
155:*/
156:
157:VGA_VIDEO_ENABLE = 'd'1;
158:
159:/* active high signal to latch new value from SRC */
160:
161:VMEM_SRC_LATCH_LOW = SREG_LOAD;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

162:VMEM_SRC_LATCH_HIGH = SREG_LOAD;
163:
164:/* VMEM_SRC_LATCHED0..7 */
165:
166:VMEM_SRC_LATCHED0.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED0) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD0);
167:VMEM_SRC_LATCHED1.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED1) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD1);
168:VMEM_SRC_LATCHED2.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED2) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD2);
169:VMEM_SRC_LATCHED3.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED3) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD3);
170:VMEM_SRC_LATCHED4.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED4) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD4);
171:VMEM_SRC_LATCHED5.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED5) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD5);
172:VMEM_SRC_LATCHED6.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED6) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD6);
173:VMEM_SRC_LATCHED7.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED7) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD7);
174:
175:VMEM_SRC_LATCHED8.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED8) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD8);
176:VMEM_SRC_LATCHED9.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED9) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD9);
177:VMEM_SRC_LATCHED10.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED10) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD10);
178:VMEM_SRC_LATCHED11.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED11) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD11);
179:VMEM_SRC_LATCHED12.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED12) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD12);
180:VMEM_SRC_LATCHED13.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED13) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD13);
181:VMEM_SRC_LATCHED14.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED14) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD14);
182:VMEM_SRC_LATCHED15.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED15) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD15);
183:
184:[VMEM_SRC_LATCHED0..15].ck = CLK_25M;
185:[VMEM_SRC_LATCHED0..15].ar = !VGA_RESET;
186:
187:/* 
188:      output color signal 
189:      GRAPHMODE0 == 0 (Text Mode) , Shift Reg & Attrib bits (VMEM bits 8,9,10,11,12,13)
190:      GRAPHMODE0 == 1 (Graph Mode), VMEM bits. VDP_HORL switches between L and H pixel data.
191:*/
192:
193:VRED_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED8) 
194:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED8) # (!VDP_HORL & VMEM_SRC_LATCHED0)));
195:
196:VRED_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED9) 
197:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED9) # (!VDP_HORL & VMEM_SRC_LATCHED1)));
198:
199:VGREEN_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED10) 
200:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED10) # (!VDP_HORL & VMEM_SRC_LATCHED2)));
201:
202:VGREEN_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED11) 
203:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED11) # (!VDP_HORL & VMEM_SRC_LATCHED3)));
204:
205:VBLUE_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED12) 
206:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED12) # (!VDP_HORL & VMEM_SRC_LATCHED4)));
207:
208:VBLUE_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED13) 
209:          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED13) # (!VDP_HORL & VMEM_SRC_LATCHED5)));
210:
211:/*
212:   VGA Config registers.  WRITE ONLY, BYTE WRITE ONLY.
213:      bit 0 = MODE, 0 for TXT, 1 for Graphics; 0 on RESET
214:      bit 1 = FONTSEL0   FONTSEL selects from 4 font libraries stored in the FONT ROM
215:      bit 2 = FONTSEL1

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

216:
217:      This register to clocked at the end of the write cycle with the deassertion of CS and R/W
218:
219:*/
220:
221:/*
222:   Access to VGA Config registers from CPU 
223:   CPU will assert /CPU_VGA_CFG_CS and /CPU_RW to indicate a write to the CGA config register.
224:   VGA_CONFIG_WRITE==1 when both CPU_CGA_CFG_CS and CPU_RW are asserted (==0). 
225:*/
226:
227:VGA_CONFIG_WRITE = !(CPU_VGA_CFG_CS # CPU_RW);
228:
229:/* VGA_BUSY is 1 when the VGA memory is bring used by the VGA interface */
230:
231:
232:FRAM_A0 = (!GRAPH_MODE0 & VSYNC_COUNTER0)
233:         # ((GRAPH_MODE0 & 'd'0));
234:FRAM_A1 = (!GRAPH_MODE0 & VSYNC_COUNTER1)
235:         # ((GRAPH_MODE0 & 'd'0));
236:FRAM_A2 = (!GRAPH_MODE0 & VSYNC_COUNTER2)
237:         # ((GRAPH_MODE0 & 'd'0));
238:FRAM_A3 = (!GRAPH_MODE0 & VSYNC_COUNTER3)
239:         # ((GRAPH_MODE0 & 'd'0));
240:
241:
242:/* Horizontal Sync 10 bit counter, 0-799.  HSYNC_ZERO is used to reset this counter so it loops from 799 back to 0 */
243:
244:HSYNC_COUNTER0.d = !HSYNC_COUNTER0 & HSYNC_ZERO;
245:HSYNC_COUNTER0.ck = CLK_25M;
246:HSYNC_COUNTER0.ar = !VGA_RESET;
247:
248:HSYNC_COUNTER1.d = ((HSYNC_COUNTER0&!HSYNC_COUNTER1) # (!HSYNC_COUNTER0&HSYNC_COUNTER1)) & HSYNC_ZERO;
249:HSYNC_COUNTER1.ck = CLK_25M;
250:HSYNC_COUNTER1.ar = !VGA_RESET;
251:
252:HSYNC_COUNTER2T = HSYNC_COUNTER0&HSYNC_COUNTER1;
253:HSYNC_COUNTER2.d = ((HSYNC_COUNTER2T&!HSYNC_COUNTER2) # (!HSYNC_COUNTER2T&HSYNC_COUNTER2)) & HSYNC_ZERO;
254:HSYNC_COUNTER2.ck = CLK_25M;
255:HSYNC_COUNTER2.ar = !VGA_RESET;
256:
257:HSYNC_COUNTER3T = HSYNC_COUNTER2T&HSYNC_COUNTER2;
258:HSYNC_COUNTER3.d = ((HSYNC_COUNTER3T&!HSYNC_COUNTER3) # (!HSYNC_COUNTER3T&HSYNC_COUNTER3)) & HSYNC_ZERO;
259:HSYNC_COUNTER3.ck = CLK_25M;
260:HSYNC_COUNTER3.ar = !VGA_RESET;
261:
262:HSYNC_COUNTER4T = HSYNC_COUNTER3T&HSYNC_COUNTER3;
263:HSYNC_COUNTER4.d = ((HSYNC_COUNTER4T&!HSYNC_COUNTER4) # (!HSYNC_COUNTER4T&HSYNC_COUNTER4)) & HSYNC_ZERO;
264:HSYNC_COUNTER4.ck = CLK_25M;
265:HSYNC_COUNTER4.ar = !VGA_RESET;
266:
267:HSYNC_COUNTER5T = HSYNC_COUNTER4T&HSYNC_COUNTER4;
268:HSYNC_COUNTER5.d = ((HSYNC_COUNTER5T&!HSYNC_COUNTER5) # (!HSYNC_COUNTER5T&HSYNC_COUNTER5)) & HSYNC_ZERO;
269:HSYNC_COUNTER5.ck = CLK_25M;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 6

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

270:HSYNC_COUNTER5.ar = !VGA_RESET;
271:
272:HSYNC_COUNTER6T = HSYNC_COUNTER5T&HSYNC_COUNTER5;
273:HSYNC_COUNTER6.d = ((HSYNC_COUNTER6T&!HSYNC_COUNTER6) # (!HSYNC_COUNTER6T&HSYNC_COUNTER6)) & HSYNC_ZERO;
274:HSYNC_COUNTER6.ck = CLK_25M;
275:HSYNC_COUNTER6.ar = !VGA_RESET;
276:
277:HSYNC_COUNTER7T = HSYNC_COUNTER6T&HSYNC_COUNTER6;
278:HSYNC_COUNTER7.d = ((HSYNC_COUNTER7T&!HSYNC_COUNTER7) # (!HSYNC_COUNTER7T&HSYNC_COUNTER7)) & HSYNC_ZERO;
279:HSYNC_COUNTER7.ck = CLK_25M;
280:HSYNC_COUNTER7.ar = !VGA_RESET;
281:
282:HSYNC_COUNTER8T = HSYNC_COUNTER7T&HSYNC_COUNTER7;
283:HSYNC_COUNTER8.d = ((HSYNC_COUNTER8T&!HSYNC_COUNTER8) # (!HSYNC_COUNTER8T&HSYNC_COUNTER8)) & HSYNC_ZERO;
284:HSYNC_COUNTER8.ck = CLK_25M;
285:HSYNC_COUNTER8.ar = !VGA_RESET;
286:
287:HSYNC_COUNTER9T = HSYNC_COUNTER8T&HSYNC_COUNTER8;
288:HSYNC_COUNTER9.d = ((HSYNC_COUNTER9T&!HSYNC_COUNTER9) # (!HSYNC_COUNTER9T&HSYNC_COUNTER9)) & HSYNC_ZERO;
289:HSYNC_COUNTER9.ck = CLK_25M;
290:HSYNC_COUNTER9.ar = !VGA_RESET;
291:
292:FIELD hsync_counter_field = [HSYNC_COUNTER9..0];
293:FIELD hsync_counter_3_field = [HSYNC_COUNTER2..0];
294:FIELD hsync_counter_4_field = [HSYNC_COUNTER3..0];
295:
296:/* 
297:   HSYNC_ZERO is 0 when we need to loop the counter.  This is Logical AND'ed with the other inputs to each
298:   counters .d value, so when we are at the loop location, the next location loaded will be 0.
299:   HSYNC_ZERO us normally at 1, and goes to 0 for 1 clock cycle ( CLK25 low to CLK25 low ), and that
300:   edge is also used to increment the vertical counters via VSYNC_CLOCK.
301:*/
302:
303:HSYNC_ZERO = !(hsync_counter_field:['d'799]);
304:
305:/* 
306:   The VSYNC_CLOCK signal is used to increment the V_SYNC counter at the end of each horizontal sync row.   
307:   The reason for two FFs is to first capture the HSYNC value (on the clock edge opposite of the counter itself changing)
308:   followed by a second FF to sync the V_SYNC increment with the rising edge of CLK_25M.   This allows both the H_SYNC and V_SYNC 
309:   counters to be used in logical operations that are clocked on the same clock signal (falling CLK_25M)
310:*/
311:
312:
313:VSYNC_CLOCK_A.d = !HSYNC_ZERO;
314:VSYNC_CLOCK_A.ck = !CLK_25M;
315:VSYNC_CLOCK_A.ar = !VGA_RESET;
316:
317:VSYNC_CLOCK_B.d = VSYNC_CLOCK_A;
318:VSYNC_CLOCK_B.ck = CLK_25M;
319:VSYNC_CLOCK_B.ar = !VGA_RESET;
320:
321:/* Vertical Sync 9 bit counter, 0-498.  VSYNC_ZERO is used to reset this counter so it loops from 498 back to 0 */
322:
323:VSYNC_COUNTER0.d = (!VSYNC_COUNTER0) & VSYNC_ZERO;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 7

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

324:VSYNC_COUNTER0.ck = VSYNC_CLOCK_B;
325:VSYNC_COUNTER0.ar = !VGA_RESET;
326:
327:VSYNC_COUNTER1.d = ((VSYNC_COUNTER0&!VSYNC_COUNTER1) # (!VSYNC_COUNTER0&VSYNC_COUNTER1)) & VSYNC_ZERO;
328:VSYNC_COUNTER1.ck = VSYNC_CLOCK_B;
329:VSYNC_COUNTER1.ar = !VGA_RESET;
330:
331:VSYNC_COUNTER2T = VSYNC_COUNTER0&VSYNC_COUNTER1;
332:VSYNC_COUNTER2.d = ((VSYNC_COUNTER2T&!VSYNC_COUNTER2) # (!VSYNC_COUNTER2T&VSYNC_COUNTER2)) & VSYNC_ZERO;
333:VSYNC_COUNTER2.ck = VSYNC_CLOCK_B;
334:VSYNC_COUNTER2.ar = !VGA_RESET;
335:
336:VSYNC_COUNTER3T = VSYNC_COUNTER2T&VSYNC_COUNTER2;
337:VSYNC_COUNTER3.d = ((VSYNC_COUNTER3T&!VSYNC_COUNTER3) # (!VSYNC_COUNTER3T&VSYNC_COUNTER3)) & VSYNC_ZERO;
338:VSYNC_COUNTER3.ck = VSYNC_CLOCK_B;
339:VSYNC_COUNTER3.ar = !VGA_RESET;
340:
341:VSYNC_COUNTER4T = VSYNC_COUNTER3T&VSYNC_COUNTER3;
342:VSYNC_COUNTER4.d = ((VSYNC_COUNTER4T&!VSYNC_COUNTER4) # (!VSYNC_COUNTER4T&VSYNC_COUNTER4)) & VSYNC_ZERO;
343:VSYNC_COUNTER4.ck = VSYNC_CLOCK_B;
344:VSYNC_COUNTER4.ar = !VGA_RESET;
345:
346:VSYNC_COUNTER5T = VSYNC_COUNTER4T&VSYNC_COUNTER4;
347:VSYNC_COUNTER5.d = ((VSYNC_COUNTER5T&!VSYNC_COUNTER5) # (!VSYNC_COUNTER5T&VSYNC_COUNTER5)) & VSYNC_ZERO;
348:VSYNC_COUNTER5.ck = VSYNC_CLOCK_B;
349:VSYNC_COUNTER5.ar = !VGA_RESET;
350:
351:VSYNC_COUNTER6T = VSYNC_COUNTER5T&VSYNC_COUNTER5;
352:VSYNC_COUNTER6.d = ((VSYNC_COUNTER6T&!VSYNC_COUNTER6) # (!VSYNC_COUNTER6T&VSYNC_COUNTER6)) & VSYNC_ZERO;
353:VSYNC_COUNTER6.ck = VSYNC_CLOCK_B;
354:VSYNC_COUNTER6.ar = !VGA_RESET;
355:
356:VSYNC_COUNTER7T = VSYNC_COUNTER6T&VSYNC_COUNTER6;
357:VSYNC_COUNTER7.d = ((VSYNC_COUNTER7T&!VSYNC_COUNTER7) # (!VSYNC_COUNTER7T&VSYNC_COUNTER7)) & VSYNC_ZERO;
358:VSYNC_COUNTER7.ck = VSYNC_CLOCK_B;
359:VSYNC_COUNTER7.ar = !VGA_RESET;
360:
361:VSYNC_COUNTER8T = VSYNC_COUNTER7T&VSYNC_COUNTER7;
362:VSYNC_COUNTER8.d = ((VSYNC_COUNTER8T&!VSYNC_COUNTER8) # (!VSYNC_COUNTER8T&VSYNC_COUNTER8)) & VSYNC_ZERO;
363:VSYNC_COUNTER8.ck = VSYNC_CLOCK_B;
364:VSYNC_COUNTER8.ar = !VGA_RESET;
365:
366:VSYNC_COUNTER9T = VSYNC_COUNTER8T&VSYNC_COUNTER8;
367:VSYNC_COUNTER9.d = ((VSYNC_COUNTER9T&!VSYNC_COUNTER9) # (!VSYNC_COUNTER9T&VSYNC_COUNTER9)) & VSYNC_ZERO;
368:VSYNC_COUNTER9.ck = VSYNC_CLOCK_B;
369:VSYNC_COUNTER9.ar = !VGA_RESET;
370:
371:FIELD vsync_counter_field = [VSYNC_COUNTER9..0];
372:FIELD vsync_counter_4_field = [VSYNC_COUNTER3..0];
373:
374:VSYNC_ZERO = !(vsync_counter_field:['d'524]);
375:
376:/* VSYNC_DISPLAY_ACTIVE == 1 when on an active output row */
377:VSYNC_DISPLAY_ACTIVE = (vsync_counter_field:[0..'d'479]);

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 8

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

378:
379:/* 
380:   VERT_SYNC_INTERRUPT is used to tell the CPU that we are entering the vertical refresh interval.
381:   VERY_SYNC_INTERRUPT goes to 1 during the active part of the display, and the falling edge indicates 
382:   entering the refresh interval
383: */
384:VERT_SYNC_INTERRUPT = VSYNC_DISPLAY_ACTIVE;
385:
386:/*  NOT USING
387:VGA_DISPLAY_ACTIVE.d = (hsync_counter_field:['d'8..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
388:VGA_DISPLAY_ACTIVE.ck = !CLK_25M;
389:VGA_DISPLAY_ACTIVE.ar = !VGA_RESET;
390:*/
391:
392:/* 
393:   RAM_OE is used by the VRAM CE ,OE, and WE lines to select when the video adapter is using VRAM.  
394:   It is active low, so ==0 indicates VRAM is being used by the video adapter 
395:*/
396:
397:RAM_OE.d = !((hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE));
398:RAM_OE.ck = !CLK_25M;
399:RAM_OE.ap = !VGA_RESET;
400:
401:VGA_BUSY.d =  ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
402:VGA_BUSY.ck = !CLK_25M;
403:VGA_BUSY.ar = !VGA_RESET;
404:
405:/* Control of VRAM */
406:/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle(including chip select), and ==1 when the VGA is in control */
407:
408:/* In graphics mode, we need to go between the low and high data values.  HC0 -> 0, HC1 -> 1 */
409:
410:VDP_HORL =  (GRAPH_MODE0 & HSYNC_COUNTER0 & !RAM_OE);
411:
412:VRAM_LOW_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_LDS );
413:VRAM_HIGH_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_UDS );
414:VRAM_OE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & !CPU_RW );
415:VRAM_WE = (CPU_VRAM_ACCESS_ENABLED # CPU_RW );
416:
417:SREG_LOAD.d = (hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]);
418:SREG_LOAD.ck = !CLK_25M;
419:SREG_LOAD.ar = !VGA_RESET;
420:
421:SREG_SHIFT.d = (hsync_counter_field:['d'7..'d'647] & vsync_counter_field:['d'0..'d'479]);
422:SREG_SHIFT.ck = !CLK_25M;
423:SREG_SHIFT.ar = !VGA_RESET;
424:
425:VGA_HSYNC.d = !(hsync_counter_field:['d'664..'d'759]);
426:VGA_HSYNC.ck = !CLK_25M;
427:VGA_HSYNC.ap = !VGA_RESET;
428:
429:VGA_VSYNC.d = !(vsync_counter_field:['d'490..'d'491]);
430:VGA_VSYNC.ck = !CLK_25M;
431:VGA_VSYNC.ar = !VGA_RESET;

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 9

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

432:
433:/*
434:      VGA_BUSY is a flag that indicates if the Video memory can be accessed by the CPU.  
435:         == 1 indicates the video controller is usig the memory
436:         == 0 indicates the memory is available for CPU access.
437:         This needs to be active outside of the video access hcount, and during the vertical
438:         refresh period. It needs a guard band around the start time to guarentee a CPU cycle can
439:         complete before the video side needs access.  
440:
441:         ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
442:
443:
444:      VGA_BUSY_CSLOCKED is a version of VGA_BUSY that is clocked at the start of a CPU
445:         access cycle.  It is used to guarentee that the video memory cannot become busy during
446:         the middle of a CPU access cycle.  As such you have to guarentee there is enough guard 
447:         time around VGA_BUSY to account for a full cpu cycle (250ns, or 7 pixle clocks)
448:         This signal is also used to trigger the SBUS_TO_VRAM_AD_OE output, which turns on the
449:         buffers that connect the CPU bus to the Video memory bus. SBUS_TO_VRAM_AD_OE in enabled
450:         when this value is 0 AND CPU_VGA_VRAM_CS is asserted (==0).   
451:
452:      CPU_VRAM_DTACK is the DTACK signal back to the CPU.  When it is 1, the CPU will add waitstates
453:         during an access until it goes to 0.  Once DTACK goes to 0, the CPU will complete the access cycle.
454:         This gate is clocked on CLK_25M, which guarentees a 19ns delay from when VGA_BUSY falls to 0.  Since the VRAM_AD_OE 
455:         is enabled as soon as VGA_BUSY falls, the address and data signals will have additional time to get to the VRAM.
456:         The VRAM OE/WE/CE signals should also be asserted using this same combinatorial. 
457:*/
458:
459:VGA_BUSY_CSLOCKED.d = VGA_BUSY;
460:VGA_BUSY_CSLOCKED.ck = !CPU_VGA_VRAM_CS;
461:VGA_BUSY_CSLOCKED.ar = !VGA_BUSY # !VGA_RESET;
462:
463:CPU_VRAM_CS_CLOCKED.d = CPU_VGA_VRAM_CS;
464:CPU_VRAM_CS_CLOCKED.ck = !CLK_25M;
465:CPU_VRAM_CS_CLOCKED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
466:
467:CPU_VRAM_ACCESS_ENABLED.d = VGA_BUSY_CSLOCKED # CPU_VRAM_CS_CLOCKED;
468:CPU_VRAM_ACCESS_ENABLED.ck = CLK_25M;
469:CPU_VRAM_ACCESS_ENABLED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
470:
471:CPU_VRAM_DTACK.d = CPU_VRAM_ACCESS_ENABLED;
472:CPU_VRAM_DTACK.ck = !CLK_25M;
473:CPU_VRAM_DTACK.ap = CPU_VGA_VRAM_CS # !VGA_RESET;
474:
475:/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle, and ==1 when the VGA is in control */
476:
477:SBUS_TO_VRAM_AD_OE = CPU_VRAM_ACCESS_ENABLED;
478:
479:/* Address Mode Generation 
480:     Address Mode is controlled by the 3 bit field VADDR_MODE[0,1,2].   Since it is an encoded field
481:     we will generate the control variables for each condition, and use those to generate the final
482:     mode.
483:
484:     RESET_ALL = In text mode, do at end last line.
485:     RESET_L6 = In text mode -

LISTING FOR LOGIC DESCRIPTION FILE: VGA4A.pld                        Page 10

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Wed Apr 26 21:14:13 2023

486:
487:     [VADDR_MODE0..2] - Address Increment Mode
488:        000  DO NOTHING   vaddr_mode_field:['d'0] 
489:        001  INCREMENT    vaddr_mode_field:['d'1]
490:        010  RESET_A6     vaddr_mode_field:['d'2]
491:        011  RESET_A6I    vaddr_mode_field:['d'3]
492:        100  RESET_ALL    vaddr_mode_field:['d'4]
493:        101  RESET_ALL    vaddr_mode_field:['d'5]
494:        110  RESET_ALL    vaddr_mode_field:['d'6]
495:        111  RESET_ALL    vaddr_mode_field:['d'7]
496:                          vaddr_mode_field:['d'4..'d'7]
497:
498:*/
499:
500:VADDR_INCREMENT = (!GRAPH_MODE0&(hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]));
501:VADDR_RESET_ALL = (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_field:['d'524]));
502:VADDR_RESET_A6 =  (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_4_field:['d'0..'d'14]));
503:VADDR_RESET_A6I = (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_4_field:['d'15]));
504:VADDR_MODE0 = VADDR_RESET_A6I # VADDR_INCREMENT;
505:VADDR_MODE1 = VADDR_RESET_A6 # VADDR_RESET_A6I;
506:VADDR_MODE2 = VADDR_RESET_ALL;
507:
508:/*
509:
510:Total dedicated input used:     2/4     (50%)
511:Total I/O pins used             59/64   (92%)
512:Total Logic cells used          96/128  (75%)
513:Total Flip-Flop used            56/128  (43%)
514:Total Foldback logic used       2/128   (1%)
515:Total Nodes+FB/MCells           96/128  (75%)
516:Total cascade used              2
517:Total input pins                36
518:Total output pins               25
519:Total Pts                       299
520:
521:*/
522:
523:
524:
525:
526:



