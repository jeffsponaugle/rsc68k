Name	 VGA4A;
PartNo   VGA4A;
Date     05/10/2022;
Revision 01;
Designer Sponaugle;
Company  Ratiometric;
Assembly None;
Location None;
Device   f1508ispplcc84;


/* 
   Version 1.12a
       Compressed and spread into 2 CPLDS.
   
*/

/*

    VRAM_AD_OE  Enable Address and Dataline buffers from CPU to video memory.

    VGA_CPU_ACCESS_ALLOWED - (hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
    VGA_BUSY - FF clocked to RAM_OE by EXP_CS_C, Cleared to 1 by VGA_BUSY==1.   
    
*/

/*  
               MHz	   Horizontal (in Pixels)	                           Vertical (in Lines)
Format	Pixel Clock    Active Video   Front_Porch Sync_Pulse  Back_Porch	Active_Video	Front_Porch	Sync_Pulse Back_Porch
640x480, 60Hz	25.175	640	         16	         -96	      48	         480	         11	        -2	         31
640x480, 72Hz	31.500	640	         24	         -40	      128	      480	         9	        -3	         2

*/


PROPERTY ATMEL {TDI_PULLUP = ON};
PROPERTY ATMEL {TMS_PULLUP = ON};

/** Inputs **/

Pin[83] = CLK_25M;                  /* 25.175Mhz input clock  - Master Pixel Clock */
Pin[1]  = VGA_RESET;                /* Active Low Reset */
Pin[10]  = CPU_VGA_VRAM_CS;         /* Chip Select from CPU to access video memory */
Pin[11] = CPU_VGA_CFG_CS;           /* Chip Select from CPU to access VGA Configuration register */
Pin[12] = CPU_UDS;                  /* CPU Upper Byte Select */
Pin[15] = CPU_LDS;                  /* CPU Lower Byte Select */
Pin[16] = CPU_RW;                   /* CPU signal for reading or writing */
Pin[17,18,20,21,22,24,25,27] = [SREG_IN0..7];      /* Data bus input for shift register.  Connect to Char ROM */

/** Outputs **/

Pin[4] = VGA_HSYNC;                 /* Horizonal Sync Output */
Pin[5] = VGA_VSYNC;                 /* Vertical Sync Output */
Pin[6] = VGA_VIDEO_ENABLE;          /* Enable Color Video Signal Output to Connector */
Pin[29] = VRAM_LOW_CE;              /* Chip Enable for Vido RAM Low Output */
Pin[30] = VRAM_HIGH_CE;             /* Chip Enable for Video RAM High Output */
Pin[31] = VRAM_OE;                  /* Output Enable for both Video RAMs  */
Pin[33] = VRAM_WE;                  /* Write Enable for both Video RAMs */
Pin[48,46] = GRAPH_MODE0,GRAPH_MODE1;       /* 00 = TEXT, 01=GRAPHICS, 10,11 Unused */

/* 
   Video Ram data bus input, RGB output, and internal lataches for data bus input.
*/

Pin [74,73,70,69,68,67,65,64,63,61,60,58,57,56,55,54]= [VMEM_SRCD0..15];      /* Databus from Video Memory */
Pin [81,80]= [VRED_OUT0..1];        /* Red Color output bits */                  
Pin [79,77]= [VGREEN_OUT0..1];      /* Green Color output bits */     
Pin [76,75]= [VBLUE_OUT0..1];       /* Blue Color output bits */     

/* Address lines that go to the character rom for text mode.  */
Pin[40,39,37,36] = [FRAM_A0..3];      /* Selects the row for a given font (16 rows per char) */   

/* Signals back to the host CPU */
Pin[9] = CPU_VRAM_DTACK;            /* Signal back to CPU to hold VRAM access cycle while video gen */
Pin[8] = VERT_SYNC_INTERRUPT;       /* Interrupt signal to CPU for start of vert refresh */

/* control line for CPU to Video RAM interface */
Pin[41] = SBUS_TO_VRAM_AD_OE;       /* Output Enable for CPU <-> Video RAM Address and Data Bus */
Pin[44] = VGA_CONFIG_WRITE;         /* Enable to second CPLD for config register write */
Pin[52,51,50] = [VADDR_MODE0..2];   /* second CPLD VRAM address increment mode */

/* Pins to second CPLD 
    VGA_CONFIG_WRITE: Signal that the CPU is writing to the config register inside the address CPLD.

    VADDR_MODE: 3 bit signal to tell the address generation CPLD what to do on the next clock cycle.

     [VADDR_MODE0..2] - Address Increment Mode
        000  DO NOTHING   vaddr_mode_field:['d'0] 
        001  INCREMENT    vaddr_mode_field:['d'1] Increment Address by 1
        010  RESET_A6     vaddr_mode_field:['d'2] Reset Lower 6 bits of Address - For Text Mode to repeat a line (for char font)
        011  RESET_A6I    vaddr_mode_field:['d'3] Reset Lower 6 bits of Address, and increment remaining upper bits by 1.  (NEXT LINE)
        100  RESET_ALL    vaddr_mode_field:['d'4] Reset All Address Bits back to TOP
        101  RESET_ALL    vaddr_mode_field:['d'5] Reset All Address Bits back to TOP
        110  RESET_ALL    vaddr_mode_field:['d'6] Reset All Address Bits back to TOP
        111  RESET_ALL    vaddr_mode_field:['d'7] Reset All Address Bits back to TOP
                          vaddr_mode_field:['d'4..'d'7]
*/

NODE [VMEM_SRC_LATCHED0..15];
NODE [HSYNC_COUNTER0..9];
NODE [VSYNC_COUNTER0..9];
NODE VSYNC_CLOCK_A,VSYNC_CLOCK_B;
NODE SREG_LOAD,SREG_SHIFT;
NODE VGA_BUSY,VGA_BUSY_CSLOCKED, CPU_VRAM_CS_CLOCKED , CPU_VRAM_ACCESS_ENABLED;
NODE RAM_OE;
NODE [SREG_D0..7];

/*  ________________________________________________________________ */
/* Shift Register Implementation 
    SREG_Dx are the storage registers.  D7 is the output.
    SREG_LOAD is an active high signal to load from SREG_IN the 8 bit value
    SREG_SHIFT is an active high signal to shift from 0-->7 on clock.   
    SREG_LOAD overrides SREG_SHIFT.
    if neither SREG_LOAD or SREG_SHIFT are high the register value stays the same.
*/

SREG_D0.d = (SREG_LOAD & SREG_IN0) # (!SREG_LOAD & !SREG_SHIFT & SREG_D0);
SREG_D1.d = (SREG_LOAD & SREG_IN1) # (!SREG_LOAD & SREG_SHIFT & SREG_D0) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D1 );
SREG_D2.d = (SREG_LOAD & SREG_IN2) # (!SREG_LOAD & SREG_SHIFT & SREG_D1) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D2 );
SREG_D3.d = (SREG_LOAD & SREG_IN3) # (!SREG_LOAD & SREG_SHIFT & SREG_D2) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D3 );
SREG_D4.d = (SREG_LOAD & SREG_IN4) # (!SREG_LOAD & SREG_SHIFT & SREG_D3) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D4 );
SREG_D5.d = (SREG_LOAD & SREG_IN5) # (!SREG_LOAD & SREG_SHIFT & SREG_D4) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D5 );
SREG_D6.d = (SREG_LOAD & SREG_IN6) # (!SREG_LOAD & SREG_SHIFT & SREG_D5) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D6 );
SREG_D7.d = (SREG_LOAD & SREG_IN7) # (!SREG_LOAD & SREG_SHIFT & SREG_D6) # ( !SREG_LOAD & !SREG_SHIFT & SREG_D7 );

SREG_D0.ck = CLK_25M;
SREG_D1.ck = CLK_25M;
SREG_D2.ck = CLK_25M;
SREG_D3.ck = CLK_25M;
SREG_D4.ck = CLK_25M;
SREG_D5.ck = CLK_25M;
SREG_D6.ck = CLK_25M;
SREG_D7.ck = CLK_25M;

SREG_D0.ar = !VGA_RESET;
SREG_D1.ar = !VGA_RESET;
SREG_D2.ar = !VGA_RESET;
SREG_D3.ar = !VGA_RESET;
SREG_D4.ar = !VGA_RESET;
SREG_D5.ar = !VGA_RESET;
SREG_D6.ar = !VGA_RESET;
SREG_D7.ar = !VGA_RESET;


/*  ________________________________________________________________ */


/* 
    Video Out MUX:  In Text mode, pass thru the RGB _IN to _OUT if SREG_D7==1 and we are in the active region.
                    In Graphics mode, pass thru RGB _IN to +_OUT all of the time if we are in the active region. 
                    Active Region is RAM_OE.
    SRC Latch activated by CLK_25 as well as SR_LOAD.  SR_LOAD is used to both latch this data as well
    as latch data into the shift register.

*/

VGA_VIDEO_ENABLE = 'd'1;

/* active high signal to latch new value from SRC */

VMEM_SRC_LATCH_LOW = SREG_LOAD;
VMEM_SRC_LATCH_HIGH = SREG_LOAD;

/* VMEM_SRC_LATCHED0..7 */

VMEM_SRC_LATCHED0.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED0) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD0);
VMEM_SRC_LATCHED1.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED1) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD1);
VMEM_SRC_LATCHED2.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED2) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD2);
VMEM_SRC_LATCHED3.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED3) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD3);
VMEM_SRC_LATCHED4.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED4) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD4);
VMEM_SRC_LATCHED5.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED5) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD5);
VMEM_SRC_LATCHED6.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED6) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD6);
VMEM_SRC_LATCHED7.d = (!VMEM_SRC_LATCH_LOW & VMEM_SRC_LATCHED7) # (VMEM_SRC_LATCH_LOW & VMEM_SRCD7);

VMEM_SRC_LATCHED8.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED8) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD8);
VMEM_SRC_LATCHED9.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED9) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD9);
VMEM_SRC_LATCHED10.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED10) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD10);
VMEM_SRC_LATCHED11.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED11) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD11);
VMEM_SRC_LATCHED12.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED12) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD12);
VMEM_SRC_LATCHED13.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED13) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD13);
VMEM_SRC_LATCHED14.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED14) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD14);
VMEM_SRC_LATCHED15.d = (!VMEM_SRC_LATCH_HIGH & VMEM_SRC_LATCHED15) # (VMEM_SRC_LATCH_HIGH & VMEM_SRCD15);

[VMEM_SRC_LATCHED0..15].ck = CLK_25M;
[VMEM_SRC_LATCHED0..15].ar = !VGA_RESET;

/* 
      output color signal 
      GRAPHMODE0 == 0 (Text Mode) , Shift Reg & Attrib bits (VMEM bits 8,9,10,11,12,13)
      GRAPHMODE0 == 1 (Graph Mode), VMEM bits. VDP_HORL switches between L and H pixel data.
*/

VRED_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED0) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED8) # (!VDP_HORL & VMEM_SRC_LATCHED0)));

VRED_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED1) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED9) # (!VDP_HORL & VMEM_SRC_LATCHED1)));

VGREEN_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED2) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED10) # (!VDP_HORL & VMEM_SRC_LATCHED2)));

VGREEN_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED3) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED11) # (!VDP_HORL & VMEM_SRC_LATCHED3)));

VBLUE_OUT0 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED4) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED12) # (!VDP_HORL & VMEM_SRC_LATCHED4)));

VBLUE_OUT1 = (!GRAPH_MODE0 & SREG_D7 & !RAM_OE & VMEM_SRC_LATCHED5) 
          # (GRAPH_MODE0 & !RAM_OE & ((VDP_HORL & VMEM_SRC_LATCHED13) # (!VDP_HORL & VMEM_SRC_LATCHED5)));

/*
   VGA Config registers.  WRITE ONLY, BYTE WRITE ONLY.
      bit 0 = MODE, 0 for TXT, 1 for Graphics; 0 on RESET
      bit 1 = FONTSEL0   FONTSEL selects from 4 font libraries stored in the FONT ROM
      bit 2 = FONTSEL1

      This register to clocked at the end of the write cycle with the deassertion of CS and R/W

*/

/*
   Access to VGA Config registers from CPU 
   CPU will assert /CPU_VGA_CFG_CS and /CPU_RW to indicate a write to the CGA config register.
   VGA_CONFIG_WRITE==1 when both CPU_CGA_CFG_CS and CPU_RW are asserted (==0). 
*/

VGA_CONFIG_WRITE = !(CPU_VGA_CFG_CS # CPU_RW);

/* VGA_BUSY is 1 when the VGA memory is bring used by the VGA interface */


FRAM_A0 = (!GRAPH_MODE0 & VSYNC_COUNTER0)
         # ((GRAPH_MODE0 & 'd'0));
FRAM_A1 = (!GRAPH_MODE0 & VSYNC_COUNTER1)
         # ((GRAPH_MODE0 & 'd'0));
FRAM_A2 = (!GRAPH_MODE0 & VSYNC_COUNTER2)
         # ((GRAPH_MODE0 & 'd'0));
FRAM_A3 = (!GRAPH_MODE0 & VSYNC_COUNTER3)
         # ((GRAPH_MODE0 & 'd'0));


/* Horizontal Sync 10 bit counter, 0-799.  HSYNC_ZERO is used to reset this counter so it loops from 799 back to 0 */

HSYNC_COUNTER0.d = !HSYNC_COUNTER0 & HSYNC_ZERO;
HSYNC_COUNTER0.ck = CLK_25M;
HSYNC_COUNTER0.ar = !VGA_RESET;

HSYNC_COUNTER1.d = ((HSYNC_COUNTER0&!HSYNC_COUNTER1) # (!HSYNC_COUNTER0&HSYNC_COUNTER1)) & HSYNC_ZERO;
HSYNC_COUNTER1.ck = CLK_25M;
HSYNC_COUNTER1.ar = !VGA_RESET;

HSYNC_COUNTER2T = HSYNC_COUNTER0&HSYNC_COUNTER1;
HSYNC_COUNTER2.d = ((HSYNC_COUNTER2T&!HSYNC_COUNTER2) # (!HSYNC_COUNTER2T&HSYNC_COUNTER2)) & HSYNC_ZERO;
HSYNC_COUNTER2.ck = CLK_25M;
HSYNC_COUNTER2.ar = !VGA_RESET;

HSYNC_COUNTER3T = HSYNC_COUNTER2T&HSYNC_COUNTER2;
HSYNC_COUNTER3.d = ((HSYNC_COUNTER3T&!HSYNC_COUNTER3) # (!HSYNC_COUNTER3T&HSYNC_COUNTER3)) & HSYNC_ZERO;
HSYNC_COUNTER3.ck = CLK_25M;
HSYNC_COUNTER3.ar = !VGA_RESET;

HSYNC_COUNTER4T = HSYNC_COUNTER3T&HSYNC_COUNTER3;
HSYNC_COUNTER4.d = ((HSYNC_COUNTER4T&!HSYNC_COUNTER4) # (!HSYNC_COUNTER4T&HSYNC_COUNTER4)) & HSYNC_ZERO;
HSYNC_COUNTER4.ck = CLK_25M;
HSYNC_COUNTER4.ar = !VGA_RESET;

HSYNC_COUNTER5T = HSYNC_COUNTER4T&HSYNC_COUNTER4;
HSYNC_COUNTER5.d = ((HSYNC_COUNTER5T&!HSYNC_COUNTER5) # (!HSYNC_COUNTER5T&HSYNC_COUNTER5)) & HSYNC_ZERO;
HSYNC_COUNTER5.ck = CLK_25M;
HSYNC_COUNTER5.ar = !VGA_RESET;

HSYNC_COUNTER6T = HSYNC_COUNTER5T&HSYNC_COUNTER5;
HSYNC_COUNTER6.d = ((HSYNC_COUNTER6T&!HSYNC_COUNTER6) # (!HSYNC_COUNTER6T&HSYNC_COUNTER6)) & HSYNC_ZERO;
HSYNC_COUNTER6.ck = CLK_25M;
HSYNC_COUNTER6.ar = !VGA_RESET;

HSYNC_COUNTER7T = HSYNC_COUNTER6T&HSYNC_COUNTER6;
HSYNC_COUNTER7.d = ((HSYNC_COUNTER7T&!HSYNC_COUNTER7) # (!HSYNC_COUNTER7T&HSYNC_COUNTER7)) & HSYNC_ZERO;
HSYNC_COUNTER7.ck = CLK_25M;
HSYNC_COUNTER7.ar = !VGA_RESET;

HSYNC_COUNTER8T = HSYNC_COUNTER7T&HSYNC_COUNTER7;
HSYNC_COUNTER8.d = ((HSYNC_COUNTER8T&!HSYNC_COUNTER8) # (!HSYNC_COUNTER8T&HSYNC_COUNTER8)) & HSYNC_ZERO;
HSYNC_COUNTER8.ck = CLK_25M;
HSYNC_COUNTER8.ar = !VGA_RESET;

HSYNC_COUNTER9T = HSYNC_COUNTER8T&HSYNC_COUNTER8;
HSYNC_COUNTER9.d = ((HSYNC_COUNTER9T&!HSYNC_COUNTER9) # (!HSYNC_COUNTER9T&HSYNC_COUNTER9)) & HSYNC_ZERO;
HSYNC_COUNTER9.ck = CLK_25M;
HSYNC_COUNTER9.ar = !VGA_RESET;

FIELD hsync_counter_field = [HSYNC_COUNTER9..0];
FIELD hsync_counter_3_field = [HSYNC_COUNTER2..0];
FIELD hsync_counter_4_field = [HSYNC_COUNTER3..0];

/* 
   HSYNC_ZERO is 0 when we need to loop the counter.  This is Logical AND'ed with the other inputs to each
   counters .d value, so when we are at the loop location, the next location loaded will be 0.
   HSYNC_ZERO us normally at 1, and goes to 0 for 1 clock cycle ( CLK25 low to CLK25 low ), and that
   edge is also used to increment the vertical counters via VSYNC_CLOCK.
*/

HSYNC_ZERO = !(hsync_counter_field:['d'799]);

/* 
   The VSYNC_CLOCK signal is used to increment the V_SYNC counter at the end of each horizontal sync row.   
   The reason for two FFs is to first capture the HSYNC value (on the clock edge opposite of the counter itself changing)
   followed by a second FF to sync the V_SYNC increment with the rising edge of CLK_25M.   This allows both the H_SYNC and V_SYNC 
   counters to be used in logical operations that are clocked on the same clock signal (falling CLK_25M)
*/


VSYNC_CLOCK_A.d = !HSYNC_ZERO;
VSYNC_CLOCK_A.ck = !CLK_25M;
VSYNC_CLOCK_A.ar = !VGA_RESET;

VSYNC_CLOCK_B.d = VSYNC_CLOCK_A;
VSYNC_CLOCK_B.ck = CLK_25M;
VSYNC_CLOCK_B.ar = !VGA_RESET;

/* Vertical Sync 9 bit counter, 0-498.  VSYNC_ZERO is used to reset this counter so it loops from 498 back to 0 */

VSYNC_COUNTER0.d = (!VSYNC_COUNTER0) & VSYNC_ZERO;
VSYNC_COUNTER0.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER0.ar = !VGA_RESET;

VSYNC_COUNTER1.d = ((VSYNC_COUNTER0&!VSYNC_COUNTER1) # (!VSYNC_COUNTER0&VSYNC_COUNTER1)) & VSYNC_ZERO;
VSYNC_COUNTER1.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER1.ar = !VGA_RESET;

VSYNC_COUNTER2T = VSYNC_COUNTER0&VSYNC_COUNTER1;
VSYNC_COUNTER2.d = ((VSYNC_COUNTER2T&!VSYNC_COUNTER2) # (!VSYNC_COUNTER2T&VSYNC_COUNTER2)) & VSYNC_ZERO;
VSYNC_COUNTER2.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER2.ar = !VGA_RESET;

VSYNC_COUNTER3T = VSYNC_COUNTER2T&VSYNC_COUNTER2;
VSYNC_COUNTER3.d = ((VSYNC_COUNTER3T&!VSYNC_COUNTER3) # (!VSYNC_COUNTER3T&VSYNC_COUNTER3)) & VSYNC_ZERO;
VSYNC_COUNTER3.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER3.ar = !VGA_RESET;

VSYNC_COUNTER4T = VSYNC_COUNTER3T&VSYNC_COUNTER3;
VSYNC_COUNTER4.d = ((VSYNC_COUNTER4T&!VSYNC_COUNTER4) # (!VSYNC_COUNTER4T&VSYNC_COUNTER4)) & VSYNC_ZERO;
VSYNC_COUNTER4.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER4.ar = !VGA_RESET;

VSYNC_COUNTER5T = VSYNC_COUNTER4T&VSYNC_COUNTER4;
VSYNC_COUNTER5.d = ((VSYNC_COUNTER5T&!VSYNC_COUNTER5) # (!VSYNC_COUNTER5T&VSYNC_COUNTER5)) & VSYNC_ZERO;
VSYNC_COUNTER5.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER5.ar = !VGA_RESET;

VSYNC_COUNTER6T = VSYNC_COUNTER5T&VSYNC_COUNTER5;
VSYNC_COUNTER6.d = ((VSYNC_COUNTER6T&!VSYNC_COUNTER6) # (!VSYNC_COUNTER6T&VSYNC_COUNTER6)) & VSYNC_ZERO;
VSYNC_COUNTER6.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER6.ar = !VGA_RESET;

VSYNC_COUNTER7T = VSYNC_COUNTER6T&VSYNC_COUNTER6;
VSYNC_COUNTER7.d = ((VSYNC_COUNTER7T&!VSYNC_COUNTER7) # (!VSYNC_COUNTER7T&VSYNC_COUNTER7)) & VSYNC_ZERO;
VSYNC_COUNTER7.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER7.ar = !VGA_RESET;

VSYNC_COUNTER8T = VSYNC_COUNTER7T&VSYNC_COUNTER7;
VSYNC_COUNTER8.d = ((VSYNC_COUNTER8T&!VSYNC_COUNTER8) # (!VSYNC_COUNTER8T&VSYNC_COUNTER8)) & VSYNC_ZERO;
VSYNC_COUNTER8.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER8.ar = !VGA_RESET;

VSYNC_COUNTER9T = VSYNC_COUNTER8T&VSYNC_COUNTER8;
VSYNC_COUNTER9.d = ((VSYNC_COUNTER9T&!VSYNC_COUNTER9) # (!VSYNC_COUNTER9T&VSYNC_COUNTER9)) & VSYNC_ZERO;
VSYNC_COUNTER9.ck = VSYNC_CLOCK_B;
VSYNC_COUNTER9.ar = !VGA_RESET;

FIELD vsync_counter_field = [VSYNC_COUNTER9..0];
FIELD vsync_counter_4_field = [VSYNC_COUNTER3..0];

VSYNC_ZERO = !(vsync_counter_field:['d'524]);

/* VSYNC_DISPLAY_ACTIVE == 1 when on an active output row */
VSYNC_DISPLAY_ACTIVE = (vsync_counter_field:[0..'d'479]);

/* 
   VERT_SYNC_INTERRUPT is used to tell the CPU that we are entering the vertical refresh interval.
   VERY_SYNC_INTERRUPT goes to 1 during the active part of the display, and the falling edge indicates 
   entering the refresh interval
 */
VERT_SYNC_INTERRUPT = 'b'1;
/* VERT_SYNC_INTERRUPT = VSYNC_DISPLAY_ACTIVE; */

/*  NOT USING
VGA_DISPLAY_ACTIVE.d = (hsync_counter_field:['d'8..'d'647]) & (VSYNC_DISPLAY_ACTIVE);
VGA_DISPLAY_ACTIVE.ck = !CLK_25M;
VGA_DISPLAY_ACTIVE.ar = !VGA_RESET;
*/

/* 
   RAM_OE is used by the VRAM CE ,OE, and WE lines to select when the video adapter is using VRAM.  
   It is active low, so ==0 indicates VRAM is being used by the video adapter 
*/

RAM_OE.d = !((hsync_counter_field:[0..'d'647]) & (VSYNC_DISPLAY_ACTIVE));
RAM_OE.ck = !CLK_25M;
RAM_OE.ap = !VGA_RESET;

VGA_BUSY.d =  ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);
VGA_BUSY.ck = !CLK_25M;
VGA_BUSY.ar = !VGA_RESET;

/* Control of VRAM */
/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle(including chip select), and ==1 when the VGA is in control */

/* In graphics mode, we need to go between the low and high data values.  HC0 -> 0, HC1 -> 1 */

VDP_HORL =  (GRAPH_MODE0 & HSYNC_COUNTER0 & !RAM_OE);

VRAM_LOW_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_LDS );
VRAM_HIGH_CE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & CPU_UDS );
VRAM_OE = (CPU_VRAM_ACCESS_ENABLED & RAM_OE) # (!CPU_VRAM_ACCESS_ENABLED & !CPU_RW );
VRAM_WE = (CPU_VRAM_ACCESS_ENABLED # CPU_RW );

SREG_LOAD.d = (hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]);
SREG_LOAD.ck = !CLK_25M;
SREG_LOAD.ar = !VGA_RESET;

SREG_SHIFT.d = (hsync_counter_field:['d'7..'d'647] & vsync_counter_field:['d'0..'d'479]);
SREG_SHIFT.ck = !CLK_25M;
SREG_SHIFT.ar = !VGA_RESET;

VGA_HSYNC.d = !(hsync_counter_field:['d'664..'d'759]);
VGA_HSYNC.ck = !CLK_25M;
VGA_HSYNC.ap = !VGA_RESET;

VGA_VSYNC.d = !(vsync_counter_field:['d'490..'d'491]);
VGA_VSYNC.ck = !CLK_25M;
VGA_VSYNC.ar = !VGA_RESET;

/*
      VGA_BUSY is a flag that indicates if the Video memory can be accessed by the CPU.  
         == 1 indicates the video controller is usig the memory
         == 0 indicates the memory is available for CPU access.
         This needs to be active outside of the video access hcount, and during the vertical
         refresh period. It needs a guard band around the start time to guarentee a CPU cycle can
         complete before the video side needs access.  

         ((hsync_counter_field:[0..'d'647]) # (hsync_counter_field:['d'792..'d'799]) ) & (VSYNC_DISPLAY_ACTIVE);


      VGA_BUSY_CSLOCKED is a version of VGA_BUSY that is clocked at the start of a CPU
         access cycle.  It is used to guarentee that the video memory cannot become busy during
         the middle of a CPU access cycle.  As such you have to guarentee there is enough guard 
         time around VGA_BUSY to account for a full cpu cycle (250ns, or 7 pixle clocks)
         This signal is also used to trigger the SBUS_TO_VRAM_AD_OE output, which turns on the
         buffers that connect the CPU bus to the Video memory bus. SBUS_TO_VRAM_AD_OE in enabled
         when this value is 0 AND CPU_VGA_VRAM_CS is asserted (==0).   

      CPU_VRAM_DTACK is the DTACK signal back to the CPU.  When it is 1, the CPU will add waitstates
         during an access until it goes to 0.  Once DTACK goes to 0, the CPU will complete the access cycle.
         This gate is clocked on CLK_25M, which guarentees a 19ns delay from when VGA_BUSY falls to 0.  Since the VRAM_AD_OE 
         is enabled as soon as VGA_BUSY falls, the address and data signals will have additional time to get to the VRAM.
         The VRAM OE/WE/CE signals should also be asserted using this same combinatorial. 
*/

VGA_BUSY_CSLOCKED.d = VGA_BUSY;
VGA_BUSY_CSLOCKED.ck = !CPU_VGA_VRAM_CS;
VGA_BUSY_CSLOCKED.ar = !VGA_BUSY # !VGA_RESET;

CPU_VRAM_CS_CLOCKED.d = CPU_VGA_VRAM_CS;
CPU_VRAM_CS_CLOCKED.ck = !CLK_25M;
CPU_VRAM_CS_CLOCKED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

CPU_VRAM_ACCESS_ENABLED.d = VGA_BUSY_CSLOCKED # CPU_VRAM_CS_CLOCKED;
CPU_VRAM_ACCESS_ENABLED.ck = CLK_25M;
CPU_VRAM_ACCESS_ENABLED.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

CPU_VRAM_DTACK.d = CPU_VRAM_ACCESS_ENABLED;
CPU_VRAM_DTACK.ck = !CLK_25M;
CPU_VRAM_DTACK.ap = CPU_VGA_VRAM_CS # !VGA_RESET;

/* CPU_VRAM_ACCESS_ENABLED == 0 when the CPU is doing an active cycle, and ==1 when the VGA is in control */

SBUS_TO_VRAM_AD_OE = CPU_VRAM_ACCESS_ENABLED;

/* Address Mode Generation 
     Address Mode is controlled by the 3 bit field VADDR_MODE[0,1,2].   Since it is an encoded field
     we will generate the control variables for each condition, and use those to generate the final
     mode.

     RESET_ALL = In text mode, do at end last line.
     RESET_L6 = In text mode -

     [VADDR_MODE0..2] - Address Increment Mode
        000  DO NOTHING   vaddr_mode_field:['d'0] 
        001  INCREMENT    vaddr_mode_field:['d'1]
        010  RESET_A6     vaddr_mode_field:['d'2]
        011  RESET_A6I    vaddr_mode_field:['d'3]
        100  RESET_ALL    vaddr_mode_field:['d'4]
        101  RESET_ALL    vaddr_mode_field:['d'5]
        110  RESET_ALL    vaddr_mode_field:['d'6]
        111  RESET_ALL    vaddr_mode_field:['d'7]
                          vaddr_mode_field:['d'4..'d'7]

*/

VADDR_INCREMENT = (!GRAPH_MODE0&(hsync_counter_3_field:['d'7] & hsync_counter_field:['d'0..'d'647]));
VADDR_RESET_ALL = (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_field:['d'524]));
VADDR_RESET_A6 =  (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_4_field:['d'0..'d'14]));
VADDR_RESET_A6I = (!GRAPH_MODE0&(hsync_counter_field:['d'799] & vsync_counter_4_field:['d'15]));
VADDR_MODE0 = VADDR_RESET_A6I # VADDR_INCREMENT;
VADDR_MODE1 = VADDR_RESET_A6 # VADDR_RESET_A6I;
VADDR_MODE2 = VADDR_RESET_ALL;

/*

Total dedicated input used:	2/4 	(50%)
Total I/O pins used		59/64 	(92%)
Total Logic cells used 		96/128 	(75%)
Total Flip-Flop used 		56/128 	(43%)
Total Foldback logic used 	2/128 	(1%)
Total Nodes+FB/MCells 		96/128 	(75%)
Total cascade used 		2
Total input pins 		36
Total output pins 		25
Total Pts 			299

*/



